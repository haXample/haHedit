Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 1 - 1


				;; aesfast.asm - MASM Developer source file.
				;; (c)2021 by helmut altmann

				;/*
				; *  FIPS-197 compliant AES implementation
				; *
				; *  Copyright (C) 2003-2006  Christophe Devine
				; *
				; *  This library is free software; you can redistribute it and/or
				; *  modify it under the terms of the GNU Lesser General Public
				; *  License, version 2.1 as published by the Free Software Foundation.
				; *
				; *  This library is distributed in the hope that it will be useful,
				; *  but WITHOUT ANY WARRANTY; without even the implied warranty of
				; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
				; *  Lesser General Public License for more details.
				; *
				; *  You should have received a copy of the GNU Lesser General Public
				; *  License along with this library; if not, write to the Free Software
				; *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
				; *  MA  02110-1301  USA
				; *
				; *  The AES block cipher was designed by Vincent Rijmen and Joan Daemen.
				; *
				; *  http://csrc.nist.gov/encryption/aes/rijndael/Rijndael.pdf
				; *  http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf
				; */
				;
				; Further development (2021 ha):
				;  Refurbished 2021, using Visual Studio 2010 (XP) and VS C++ 2019 (Windows 10)
				;  and transscribed into assembling language by helmut altmann for use with the
				;  Microsoft (R) Macro Assembler Version 14.28.29910.0
				;
				;; This program is free software; you can redistribute it and/or modify
				;; it under the terms of the GNU General Public License as published by
				;; the Free Software Foundation; either version 2 of the License, or
				;; (at your option) any later version.
				;;
				;; This program is distributed in the hope that it will be useful,
				;; but WITHOUT ANY WARRANTY; without even the implied warranty of
				;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
				;; GNU General Public License for more details.
				;;
				;; You should have received a copy of the GNU General Public License
				;; along with this program; see the file COPYING.  If not, write to
				;; the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
				;; Boston, MA 02111-1307, USA.
				 
				                                ;  (alternatively used MASM's "ALIGN" technique) 

				.MODEL FLAT
				        .686P
				        .XMM

				include aesfast.inc
			      C ;; aesfast.inc - MASM Developer source file.
			      C ;; (c)2021 by helmut altmann
			      C 
			      C ;; This program is free software; you can redistribute it and/or modify
			      C ;; it under the terms of the GNU General Public License as published by
			      C ;; the Free Software Foundation; either version 2 of the License, or
			      C ;; (at your option) any later version.
			      C ;;
			      C ;; This program is distributed in the hope that it will be useful,
			      C ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
			      C ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
			      C ;; GNU General Public License for more details.
			      C ;;
			      C ;; You should have received a copy of the GNU General Public License
			      C ;; along with this program; see the file COPYING.  If not, write to
			      C ;; the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
			      C ;; Boston, MA 02111-1307, USA.
			      C 
			      C ;
			      C ; Structure definitions for aesfast.asm
			      C ;
 00000204		      C _ctxStruct STRUCT               ; ctx STRUCT (ctxAesContext)
 00000000  00000100 [	      C   erk   DB 256 DUP (?)          ; Encryption round keys
	    00
	   ]
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 2 - 1


 00000100  00000100 [	      C   drk   DB 256 DUP (?)          ; Decipher round keys
	    00
	   ]
			      C   UNION
 00000200  00000004 [	      C     rkEnd DB 4 DUP (?)          ; End of round keys area
	    00
	   ]
			      C     rnr   DB 4 DUP (?)          ;  rsp. Number of rounds
			      C   ENDS     
			      C _ctxStruct ENDS
			      C  
			      C ;
			      C ; Macro definitions employed in aesfast.asm
			      C ;
			      C ;-----------------------------------------------  
			      C ;  #define GET_UINT32_BE(n,b,i)                 \
			      C ;  {                                            \
			      C ;      (n) = ( (uint32) (b)[(i)    ] << 24 )    \
			      C ;          | ( (uint32) (b)[(i) + 1] << 16 )    \
			      C ;          | ( (uint32) (b)[(i) + 2] <<  8 )    \
			      C ;          | ( (uint32) (b)[(i) + 3]       );   \
			      C ;  }
			      C ;-----------------------------------------------  
			      C         ; _GET_UINT32 _X0, _input, 0                    ; Get enc / dec data
			      C _GET_UINT32 MACRO _x, _buf, _i
			      C         mov      ecx, DWORD PTR _buf
			      C         mov      eax, DWORD PTR [ecx+_i*SIZEOF DWORD]
			      C         bswap    eax                                    ; Reverse the byte order
			      C         mov      ecx, DWORD PTR _RK                     ; X0 ^= RK[i];
			      C         xor      eax, DWORD PTR [ecx+_i*SIZEOF DWORD]    
			      C         mov      DWORD PTR _x, eax                      ; Bits[31:0]
			      C         ENDM
			      C                                          
			      C ;-----------------------------------------------  
			      C ;  #define PUT_UINT32_BE(n,b,i)                 \
			      C ;  {                                            \
			      C ;      (b)[(i)    ] = (uint8) ( (n) >> 24 );    \
			      C ;      (b)[(i) + 1] = (uint8) ( (n) >> 16 );    \
			      C ;      (b)[(i) + 2] = (uint8) ( (n) >>  8 );    \
			      C ;      (b)[(i) + 3] = (uint8) ( (n)       );    \
			      C ;  }                                            
			      C ;-----------------------------------------------  
			      C         ; _PUT_UINT32 _X0, _output, 0                   ; Put enc / dec data
			      C _PUT_UINT32 MACRO _x, _buf, _i
			      C         mov      ecx, DWORD PTR _buf
			      C         mov      eax, DWORD PTR _x                      ; Bits[31:0]
			      C         bswap    eax                                    ; Reverse the byte order
			      C         mov      DWORD PTR [ecx+_i*SIZEOF DWORD], eax   ; Bits[31:0]
			      C         ENDM
			      C 
			      C 
			      C ; AES-ENCRYPT/DECIPHER
			      C ;----------------------------------------------------------------  
			      C ;  #define AES_ROUND(FT,X0,X1,X2,X3,Y0,Y1,Y2,Y3,RK0,RK1,RK2,RK3) \
			      C ;  {                                                             \
			      C ;      RK += 4;                                                  \
			      C ;                                                                \
			      C ;      X0 = RK[0] ^ FT0[ (uint8) ( Y0 >> 24 ) ] ^                \
			      C ;                   FT1[ (uint8) ( Y1 >> 16 ) ] ^                \
			      C ;                   FT2[ (uint8) ( Y2 >>  8 ) ] ^                \
			      C ;                   FT3[ (uint8) ( Y3       ) ];                 \
			      C ;                                                                \
			      C ;      X1 = RK[1] ^ FT0[ (uint8) ( Y1 >> 24 ) ] ^                \
			      C ;                   FT1[ (uint8) ( Y2 >> 16 ) ] ^                \
			      C ;                   FT2[ (uint8) ( Y3 >>  8 ) ] ^                \
			      C ;                   FT3[ (uint8) ( Y0       ) ];                 \
			      C ;                                                                \
			      C ;      X2 = RK[2] ^ FT0[ (uint8) ( Y2 >> 24 ) ] ^                \
			      C ;                   FT1[ (uint8) ( Y3 >> 16 ) ] ^                \
			      C ;                   FT2[ (uint8) ( Y0 >>  8 ) ] ^                \
			      C ;                   FT3[ (uint8) ( Y1       ) ];                 \
			      C ;                                                                \
			      C ;      X3 = RK[3] ^ FT0[ (uint8) ( Y3 >> 24 ) ] ^                \
			      C ;                   FT1[ (uint8) ( Y0 >> 16 ) ] ^                \
			      C ;                   FT2[ (uint8) ( Y1 >>  8 ) ] ^                \
			      C ;                   FT3[ (uint8) ( Y2       ) ];                 \
			      C ;  }                                                           
			      C ;----------------------------------------------------------------   
			      C ;----------------------------------------------------------------          
			      C ;  #define AES_ROUND(RT,X0,X3,X2,X1,Y0,Y3,Y2,Y1,RK0,RK3,RK2,RK1) \
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 3 - 1


			      C ;  {                                                             \
			      C ;      RK += 4;                                                  \
			      C ;                                                                \
			      C ;      X0 = RK[0] ^ RT0[ (uint8) ( Y0 >> 24 ) ] ^                \
			      C ;                   RT1[ (uint8) ( Y3 >> 16 ) ] ^                \
			      C ;                   RT2[ (uint8) ( Y2 >>  8 ) ] ^                \
			      C ;                   RT3[ (uint8) ( Y1       ) ];                 \
			      C ;                                                                \
			      C ;      X3 = RK[3] ^ RT0[ (uint8) ( Y1 >> 24 ) ] ^                \
			      C ;                   RT1[ (uint8) ( Y0 >> 16 ) ] ^                \
			      C ;                   RT2[ (uint8) ( Y3 >>  8 ) ] ^                \
			      C ;                   RT3[ (uint8) ( Y2       ) ];                 \
			      C ;                                                                \
			      C ;      X2 = RK[2] ^ RT0[ (uint8) ( Y2 >> 24 ) ] ^                \
			      C ;                   RT1[ (uint8) ( Y1 >> 16 ) ] ^                \
			      C ;                   RT2[ (uint8) ( Y0 >>  8 ) ] ^                \
			      C ;                   RT3[ (uint8) ( Y3       ) ];                 \
			      C ;                                                                \
			      C ;      X1 = RK[1] ^ RT0[ (uint8) ( Y3 >> 24 ) ] ^                \
			      C ;                   RT1[ (uint8) ( Y2 >> 16 ) ] ^                \
			      C ;                   RT2[ (uint8) ( Y1 >>  8 ) ] ^                \
			      C ;                   RT3[ (uint8) ( Y0       ) ];                 \
			      C ;  }
			      C ;----------------------------------------------------------------  
			      C AES_ROUND_CODE MACRO _cTab, _a, _b, _rk0, _rk1, _rk2, _rk3 
			      C         mov      eax, DWORD PTR [ecx+_rk0*SIZEOF DWORD]              ; ecx = RK[0]
			      C         mov      edx, DWORD PTR @CatStr(_b,_rk0)                     ; b0
			      C         shr      edx, 24                        
			      C         movzx    edx, dl
			      C         xor      eax, DWORD PTR @CatStr(_cTab,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
			      C         mov      edx, DWORD PTR @CatStr(_b,_rk1)                     ; b1    / b3
			      C         shr      edx, 16                        
			      C         movzx    edx, dl
			      C         xor      eax, DWORD PTR @CatStr(_cTab,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
			      C         mov      edx, DWORD PTR @CatStr(_b,_rk2)                     ; b2
			      C         shr      edx, 8
			      C         movzx    edx, dl
			      C         xor      eax, DWORD PTR @CatStr(_cTab,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
			      C         movzx    edx, BYTE PTR @CatStr(_b,_rk3)                      ; b3    / b1
			      C         xor      eax, DWORD PTR @CatStr(_cTab,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
			      C         mov      DWORD PTR @CatStr(_a,_rk0), eax                     ; a0
			      C         ENDM
			      C 
			      C         ; 01 AES_FROUND(Y0,Y1,Y2,Y3, X0,X1,X2,X3);
			      C         ; AES_ROUND _Y, _X, 0,1,2,3     
			      C         ; 02 AES_FROUND(X0,X1,X2,X3, Y0,Y1,Y2,Y3);
			      C         ; AES_ROUND _X, _Y, 0,1,2,3     
			      C AES_ROUND MACRO _a, _b, _rk0, _rk1, _rk2, _rk3 
			      C         LOCAL    ???aesr1, ???aesr2
			      C 
			      C         add      DWORD PTR _RK, 4*SIZEOF DWORD          ; RK += 4; ; ecx = RK           
			      C         mov      ecx, DWORD PTR _RK                                  
			      C         cmp      DWORD PTR aesMode, _ctxStruct.drk      ; Check: ENCRYPT / DECIPHER
			      C         je       ???aesr1                                       
			      C                                                                 ; Encrypt   
			      C         AES_ROUND_CODE _FT, _a, _b, _rk0, _rk1, _rk2, _rk3      ; 0,1,2,3   
			      C         AES_ROUND_CODE _FT, _a, _b, _rk1, _rk2, _rk3, _rk0      ; 1,2,3,0   
			      C         AES_ROUND_CODE _FT, _a, _b, _rk2, _rk3, _rk0, _rk1      ; 2,3,0,1   
			      C         AES_ROUND_CODE _FT, _a, _b, _rk3, _rk0, _rk1, _rk2      ; 3,0,1,2   
			      C         jmp      ???aesr2
			      C 
			      C ???aesr1:                                                       ; Decipher  
			      C         AES_ROUND_CODE _RT, _a, _b, _rk0, _rk3, _rk2, _rk1      ; 0,3,2,1  
			      C         AES_ROUND_CODE _RT, _a, _b, _rk3, _rk2, _rk1, _rk0      ; 3,2,1,0  
			      C         AES_ROUND_CODE _RT, _a, _b, _rk2, _rk1, _rk0, _rk3      ; 2,1,0,3  
			      C         AES_ROUND_CODE _RT, _a, _b, _rk1, _rk0, _rk3, _rk2      ; 1,0,3,2  
			      C ???aesr2:
			      C         ENDM                                                                        
			      C 
			      C 
			      C ; AES-ENCRYPT/DECIPHER (Last Round SBOX)
			      C ;---------------------------------------------------------------           
			      C ; #define AES_LAST_ROUND Fsb(X0,X1,X2,X3,Y0,Y1,Y2,Y3)           \
			      C ; {                                                             \           
			      C ;     RK += 4;                                                  \
			      C ;                                                               \
			      C ;     X0 = RK[0] ^ ( FSb[ (uint8) ( Y0 >> 24 ) ] << 24 ) ^      \
			      C ;                  ( FSb[ (uint8) ( Y1 >> 16 ) ] << 16 ) ^      \
			      C ;                  ( FSb[ (uint8) ( Y2 >>  8 ) ] <<  8 ) ^      \
			      C ;                  ( FSb[ (uint8) ( Y3       ) ]       );       \
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 4 - 1


			      C ;                                                               \
			      C ;     X1 = RK[1] ^ ( FSb[ (uint8) ( Y1 >> 24 ) ] << 24 ) ^      \
			      C ;                  ( FSb[ (uint8) ( Y2 >> 16 ) ] << 16 ) ^      \
			      C ;                  ( FSb[ (uint8) ( Y3 >>  8 ) ] <<  8 ) ^      \
			      C ;                  ( FSb[ (uint8) ( Y0       ) ]       );       \
			      C ;                                                               \
			      C ;     X2 = RK[2] ^ ( FSb[ (uint8) ( Y2 >> 24 ) ] << 24 ) ^      \
			      C ;                  ( FSb[ (uint8) ( Y3 >> 16 ) ] << 16 ) ^      \
			      C ;                  ( FSb[ (uint8) ( Y0 >>  8 ) ] <<  8 ) ^      \
			      C ;                  ( FSb[ (uint8) ( Y1       ) ]       );       \
			      C ;                                                               \
			      C ;     X3 = RK[3] ^ ( FSb[ (uint8) ( Y3 >> 24 ) ] << 24 ) ^      \
			      C ;                  ( FSb[ (uint8) ( Y0 >> 16 ) ] << 16 ) ^      \
			      C ;                  ( FSb[ (uint8) ( Y1 >>  8 ) ] <<  8 ) ^      \
			      C ;                  ( FSb[ (uint8) ( Y2       ) ]       );       \
			      C ; )
			      C ;---------------------------------------------------------------           
			      C ;---------------------------------------------------------------           
			      C ; #define AES_LAST_ROUND Rsb(X0,X1,X2,X3,Y0,Y1,Y2,Y3)           \
			      C ; {                                                             \
			      C ;     RK += 4;                                                  \
			      C ;                                                               \
			      C ;     X0 = RK[0] ^ ( RSb[ (uint8) ( Y0 >> 24 ) ] << 24 ) ^      \
			      C ;                  ( RSb[ (uint8) ( Y3 >> 16 ) ] << 16 ) ^      \
			      C ;                  ( RSb[ (uint8) ( Y2 >>  8 ) ] <<  8 ) ^      \
			      C ;                  ( RSb[ (uint8) ( Y1       ) ]       );       \
			      C ;                                                               \
			      C ;     X1 = RK[1] ^ ( RSb[ (uint8) ( Y1 >> 24 ) ] << 24 ) ^      \
			      C ;                  ( RSb[ (uint8) ( Y0 >> 16 ) ] << 16 ) ^      \
			      C ;                  ( RSb[ (uint8) ( Y3 >>  8 ) ] <<  8 ) ^      \
			      C ;                  ( RSb[ (uint8) ( Y2       ) ]       );       \
			      C ;                                                               \
			      C ;     X2 = RK[2] ^ ( RSb[ (uint8) ( Y2 >> 24 ) ] << 24 ) ^      \
			      C ;                  ( RSb[ (uint8) ( Y1 >> 16 ) ] << 16 ) ^      \
			      C ;                  ( RSb[ (uint8) ( Y0 >>  8 ) ] <<  8 ) ^      \
			      C ;                  ( RSb[ (uint8) ( Y3       ) ]       );       \
			      C ;                                                               \
			      C ;     X3 = RK[3] ^ ( RSb[ (uint8) ( Y3 >> 24 ) ] << 24 ) ^      \
			      C ;                  ( RSb[ (uint8) ( Y2 >> 16 ) ] << 16 ) ^      \
			      C ;                  ( RSb[ (uint8) ( Y1 >>  8 ) ] <<  8 ) ^      \
			      C ;                  ( RSb[ (uint8) ( Y0       ) ]       );       \
			      C ; )
			      C ;---------------------------------------------------------------           
			      C AES_LAST_ROUND_CODE MACRO _sBox, _a, _b, _i0, _i1, _i2, _i3
			      C         mov      eax, DWORD PTR [ecx+_i0*SIZEOF DWORD]  ; RK[0]
			      C         mov      edx, DWORD PTR  @CatStr(_b,_i0)        ; _b0
			      C         shr      edx, 24                        
			      C         movzx    edx, dl
			      C         movzx    edx, BYTE PTR _sBox[edx]               ; Fsb / RSb[(uint8)(Y0 >> 24)]
			      C         shl      edx, 24                        
			      C         xor      eax, edx
			      C         mov      edx, DWORD PTR @CatStr(_b,_i1)         ; _b1
			      C         shr      edx, 16                        
			      C         movzx    edx, dl
			      C         movzx    edx, BYTE PTR _sBox[edx]
			      C         shl      edx, 16                        
			      C         xor      eax, edx
			      C         mov      edx, DWORD PTR @CatStr(_b,_i2)         ; _b2
			      C         shr      edx, 8
			      C         movzx    edx, dl
			      C         movzx    edx, BYTE PTR _sBox[edx]
			      C         shl      edx, 8
			      C         xor      eax, edx
			      C         movzx    edx, BYTE PTR @CatStr(_b,_i3)          ; _b3
			      C         movzx    edx, BYTE PTR _sBox[edx]
			      C         xor      eax, edx
			      C         mov      DWORD PTR @CatStr(_a,_i0), eax         ; _a0
			      C         ENDM
			      C 
			      C         ; 10th/12th/14th Final Round
			      C         ; AES_LAST_ROUND _X, _Y, 0,1,2,3
			      C AES_LAST_ROUND MACRO _a, _b, _i0, _i1, _i2, _i3
			      C         LOCAL    ???aeslr1, ???aeslr2
			      C 
			      C         mov      ecx, DWORD PTR _RK                             ; RK += 4; ; ecx = RK   
			      C         add      ecx, 4*SIZEOF DWORD                                                    
			      C         cmp      DWORD PTR aesMode, _ctxStruct.drk              ; Check: ENCRYPT / DECIPHER
			      C         je       ???aeslr1                                      
			      C                                                                 ; Encrypt   ; Decipher
			      C         AES_LAST_ROUND_CODE _Fsb, _a, _b, _i0, _i1, _i2, _i3    ; 0,1,2,3   ; 0,3,2,1
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 5 - 1


			      C         AES_LAST_ROUND_CODE _Fsb, _a, _b, _i1, _i2, _i3, _i0    ; 1,2,3,0   ; 3,2,1,0
			      C         AES_LAST_ROUND_CODE _Fsb, _a, _b, _i2, _i3, _i0, _i1    ; 2,3,0,1   ; 2,1,0,3
			      C         AES_LAST_ROUND_CODE _Fsb, _a, _b, _i3, _i0, _i1, _i2    ; 3,0,1,2   ; 1,0,3,2
			      C         jmp      ???aeslr2                                                              
			      C 
			      C ???aeslr1:                                                      ; Encrypt   ; Decipher
			      C         AES_LAST_ROUND_CODE _Rsb, _a, _b, _i0, _i3, _i2, _i1    ; 0,1,2,3   ; 0,3,2,1
			      C         AES_LAST_ROUND_CODE _Rsb, _a, _b, _i3, _i2, _i1, _i0    ; 1,2,3,0   ; 3,2,1,0
			      C         AES_LAST_ROUND_CODE _Rsb, _a, _b, _i2, _i1, _i0, _i3    ; 2,3,0,1   ; 2,1,0,3
			      C         AES_LAST_ROUND_CODE _Rsb, _a, _b, _i1, _i0, _i3, _i2    ; 3,0,1,2   ; 1,0,3,2
			      C ???aeslr2:
			      C         ENDM
			      C 
			      C 
			      C ;-----------------------------------------------------------
			      C ;
			      C ;       Initialization Macros
			      C ;
			      C         ; *SK++ = KT0[ (uint8) ( *RK >> 24 ) ] ^
			      C         ;         KT1[ (uint8) ( *RK >> 16 ) ] ^
			      C         ;         KT2[ (uint8) ( *RK >>  8 ) ] ^
			      C         ;         KT3[ (uint8) ( *RK       ) ]; RK++;
			      C SET_KEY_CODE MACRO _i
			      C         mov      eax, DWORD PTR [ecx+_i*SIZEOF DWORD]     ; eax = RK[0]
			      C         shr      eax, 24
			      C         movzx    eax, al
			      C         mov      eax, DWORD PTR _KT0[eax*SIZEOF DWORD]
			      C         mov      ebx, DWORD PTR [ecx+_i*SIZEOF DWORD]     ; ebx = RK[0]
			      C         shr      ebx, 16
			      C         movzx    ebx, bl
			      C         xor      eax, DWORD PTR _KT1[ebx*SIZEOF DWORD]
			      C         mov      ebx, DWORD PTR [ecx+_i*SIZEOF DWORD]     ; ebx = RK[0]
			      C         shr      ebx, 8
			      C         movzx    ebx, bl
			      C         xor      eax, DWORD PTR _KT2[ebx*SIZEOF DWORD]
			      C         movzx    ebx, BYTE PTR [ecx+_i*SIZEOF DWORD]      ; ebx = RK[0]
			      C         xor      eax, DWORD PTR _KT3[ebx*SIZEOF DWORD]
			      C         mov      DWORD PTR [edx+_i*SIZEOF DWORD], eax     ; SK[0] = eax
			      C         ENDM
			      C 
			      C         ; SET_KEY 0,1,2,3
			      C SET_KEY MACRO _i0, _i1, _i2, _i3
			      C         SET_KEY_CODE _i0
			      C         SET_KEY_CODE _i1
			      C         SET_KEY_CODE _i2
			      C         SET_KEY_CODE _i3
			      C         ENDM
			      C 
			      C 
			      C         ; RK[4]  = RK[0] ^ RCON[i] ^
			      C         ;     ( FSb[ (uint8) ( RK[3] >> 16 ) ] << 24 ) ^
			      C         ;     ( FSb[ (uint8) ( RK[3] >>  8 ) ] << 16 ) ^
			      C         ;     ( FSb[ (uint8) ( RK[3]       ) ] <<  8 ) ^
			      C         ;     ( FSb[ (uint8) ( RK[3] >> 24 ) ]       );
			      C         ; KEYSIZE_SBOX_RCON 3,4                           ; Params: 128/32-1, 128/32
			      C         ; KEYSIZE_SBOX_RCON 5,6                           ; Params: 192/32-1, 192/32
			      C         ; KEYSIZE_SBOX_RCON 7,8                           ; Params: 256/32-1, 256/32
			      C KEYSIZE_SBOX_RCON MACRO _i3, _i4
			      C         mov      eax, DWORD PTR [ecx+0*SIZEOF DWORD]      ; eax = RK[0]
			      C         xor      eax, DWORD PTR _RCON[edx*SIZEOF DWORD]   ; RCON[i]
			      C         mov      edx, DWORD PTR [ecx+_i3*SIZEOF DWORD]    ; RK[3]
			      C         shr      edx, 16
			      C         movzx    edx, dl
			      C         movzx    edx, BYTE PTR _FSb[edx]
			      C         shl      edx, 24
			      C         xor      eax, edx                                 
			      C         mov      edx, DWORD PTR [ecx+_i3*SIZEOF DWORD]    ; RK[3]
			      C         shr      edx, 8
			      C         movzx    edx, dl
			      C         movzx    edx, BYTE PTR _FSb[edx]
			      C         shl      edx, 16
			      C         xor      eax, edx
			      C         movzx    edx, BYTE PTR [ecx+_i3*SIZEOF DWORD]     ; RK[3]
			      C         movzx    edx, BYTE PTR _FSb[edx]
			      C         shl      edx, 8
			      C         xor      eax, edx
			      C         mov      edx, DWORD PTR [ecx+_i3*SIZEOF DWORD]    ; RK[3]
			      C         shr      edx, 24
			      C         movzx    edx, dl
			      C         movzx    edx, BYTE PTR _FSb[edx]
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 6 - 1


			      C         xor      eax, edx
			      C         mov      DWORD PTR [ecx+_i4*SIZEOF DWORD], eax    ; RK[4] = eax
			      C         ENDM
			      C 
			      C         ; ROTR8(x) ( ( ( x << 24 ) & 0xFFFFFFFF ) | \
			      C         ;            ( ( x & 0xFFFFFFFF ) >> 8 ) )
			      C         ; RT1[i] = ROTR8( RT0[i] );
			      C         ; AES_ROTATE_I _FT0, _FT1
			      C AES_ROTATE_I MACRO _rt1, _rt0
			      C         mov      edx, DWORD PTR _rt1[ecx*SIZEOF DWORD]
			      C         shl      edx, 24
			      C         mov      eax, DWORD PTR _rt1[ecx*SIZEOF DWORD]
			      C         shr      eax, 8
			      C         or       edx, eax
			      C         mov      DWORD PTR _rt0[ecx*SIZEOF DWORD], edx   ; RT1[i]
			      C         ENDM
			      C 
			      C         ; MUL(i,y) ( ( i && y ) ? pow[(log[i] + log[y]) % 255] : 0 );
			      C         ; AES_DIV_GF 11
			      C         ; AES_DIV_GF 13
			      C         ; AES_DIV_GF 09
			      C         ; AES_DIV_GF 14
			      C AES_DIV_GF MACRO _y
			      C         movzx    eax, BYTE PTR _log[_y]  ; eax = _log[0x0B], ecx = log[y]
			      C         movzx    ecx, BYTE PTR _log[edx] ; The CDQ instruction
			      C         add      eax, ecx                ;  copies the sign (bit 31) of the value in the EAX register
			      C         cdq                              ;   into every bit position in the EDX register [edx::eax].
			      C         mov      ecx, 255                ; IDIV divides the (signed) value in the [edx::eax]
			      C         idiv     ecx                     ;  by operand (divisor) - result in the [edx::eax] registers.
			      C         movzx    edx, BYTE PTR _pow[edx] ; pow[(log[i] + log[y]) % 255];  
			      C         ENDM
			      C 
				;------------------------------------------------------------------------------
				; File c:\temp600\__\aes.cpp
				; Function compile flags: /Odtp                                

				;
				; Supported AES Algorithm Modes
				;
 = 00000000			ENCRYPT  EQU    0 ; Encrypts a block of plain text (see desmain.cpp)
 = 00000001			DECIPHER EQU    1 ; Deciphers a block of encrypted text (see aesfastmain.cpp)

				;------------------------------------------------------------------------------
 00000000			_BSS SEGMENT
 00000000  00000001 [		kt_init DD 1 DUP (0)    ; aesSetKey, aesGenerateTables (Performance)
	    00000000
	   ]
 00000004  00000001 [		aesMode DD 1 DUP (?)    ; ENCRYPT or DECIPHER
	    00000000
	   ]

 00000008  00000204 [		ctxAesContext  DB (SIZEOF _ctxStruct) DUP (?)  ; (2*256)+4 DUP (?)
	    00
	   ]

 = 00000100			_SIZE_SBOX        EQU 256
 = 00000100			_SIZE_TABLE       EQU 256
 = 0000000A			_SIZE_ROUND_CONST EQU  10

 0000020C  00000100 [		_KT3    DD      _SIZE_TABLE DUP (?)
	    00000000
	   ]
 0000060C  00000100 [		_KT2    DD      _SIZE_TABLE DUP (?)
	    00000000
	   ]
 00000A0C  00000100 [		_KT1    DD      _SIZE_TABLE DUP (?)
	    00000000
	   ]
 00000E0C  00000100 [		_KT0    DD      _SIZE_TABLE DUP (?)
	    00000000
	   ]

 0000120C  00000100 [		_FT3    DD      _SIZE_TABLE DUP (?)
	    00000000
	   ]
 0000160C  00000100 [		_FT2    DD      _SIZE_TABLE DUP (?)
	    00000000
	   ]
 00001A0C  00000100 [		_FT1    DD      _SIZE_TABLE DUP (?)
	    00000000
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 7 - 1


	   ]
 00001E0C  00000100 [		_FT0    DD      _SIZE_TABLE DUP (?)
	    00000000
	   ]

 0000220C  00000100 [		_RT0    DD      _SIZE_TABLE DUP (?)
	    00000000
	   ]
 0000260C  00000100 [		_RT1    DD      _SIZE_TABLE DUP (?)
	    00000000
	   ]
 00002A0C  00000100 [		_RT2    DD      _SIZE_TABLE DUP (?)
	    00000000
	   ]
 00002E0C  00000100 [		_RT3    DD      _SIZE_TABLE DUP (?)
	    00000000
	   ]

 0000320C  00000100 [		_FSb    DB      _SIZE_SBOX DUP (?)
	    00
	   ]
 0000330C  00000100 [		_RSb    DB      _SIZE_SBOX DUP (?)
	    00
	   ]

 0000340C  0000000A [		_RCON   DD      _SIZE_ROUND_CONST DUP (?)
	    00000000
	   ]
 00003434			_BSS    ENDS

 00000000			_TEXT SEGMENT

				;------------------------------------------------------------------------------
				;
				;                       aesGenerateTables
				;
				;               COMDAT ?aesGenerateTables@@YAXXZ
				;
				;   Change: Removed usage of [ebp] to allow "INVOKE" addressing technique.
				;           (the optimizing C++ Compiler foces direct [esp] addresiing
				;            to gain [ebp] as an additional multipurpose register) 
				;
 00000000			aesGenerateTables PROC C
				        LOCAL   _log[_SIZE_TABLE]:BYTE       ; uint8 log[256];
				        LOCAL   _pow[_SIZE_TABLE]:BYTE       ; uint8 pow[256];
				        LOCAL   _tv1:DWORD           
				        LOCAL   _tv2:DWORD           
				        LOCAL   _tv3:DWORD
				        LOCAL   __i:DWORD            ; int i;
				        LOCAL   __x:BYTE             ; uint8 x, y;
				        LOCAL   __y:BYTE

				; // compute pow and log tables over GF(2^8), Modulo 2, so that 1+1=0
				;
				; https://www.samiam.org/galois.html
				; Rijndael's Galois Field GF(2) only allows an 8 bit number (0 to 255)
				; Addition and subtraction are performed by the exclusive or operation.
				;  The two operations are the same.
				;  There is no difference between addition and subtraction.
				;
				; Multiplication in Rijndael's Galois Field is a little more complicated.
				; The procedure is as follows:
				;
				; Take two eight-bit numbers, x and y, and an 8bit product p
				; - Set the product to zero.
				; - Make a copy of x and y, which we will simply call x and y
				;    in the rest of this algorithm.
				; - Run the following loop eight times:
				; 1. If the low bit of y is set, XOR the product p by the value of x
				; 2. Keep track of whether the high (eighth from left) bit of x is set to 1
				; 3. Rotate x one bit to the left, discarding the high bit,
				;     and making the low bit have a value of zero
				; 4. If x's hi bit had a value of 1 prior to this rotation,
				;     XOR x with the hexadecimal number 0x1B (27)
				; 5. Rotate y one bit to the right, discarding the low bit,
				;     and making the high (eighth from left) bit have a value of zero. 
				; - The product p now has the product of x and y
				;
				; Example: x=7, y=3, p=0
				; 1. Low bit of y is one. Product is made 7 as a result
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 8 - 1


				;    x, which is 7 (0x07), is rotated one bit to the left.
				;     This makes x have a value of 0x0E (14)
				;    The high bit of x is not set (x is below 128),
				;     so x is not XORed with 0x1B (27)
				;    y is rotated one bit to the right. y now has a value of 1 (0x01)
				; 2. Low bit of y is 1. Product, which was 7, is made 7 XOR 0x0E (14),
				;     which has a value of 9.
				;    x, which is 14, is rotate one bit to the left.
				;     This makes x have a value of 0x1C (28)
				;    The high bit of x is not set (x is below 0x80 (128),
				;     so x is not XORed with 0x1B (27)
				;    y is rotated one bit to the right. y now has a value of zero 
				;
				; While there are six more steps, none of them will affect the product p,
				; so we will discard them in this example. Note that, if this method
				; of multiplying two numbers together is used in the real world,
				; the six steps should be performed in order to protect key information
				; from being leaked via a timing attack.
				; The final product is p=0x09. 
				;
				; Exponents and logarithms
				; Exponentiation is done by repeated multiplication of the same number.
				; With some, but not all, numbers in Rijndael's Galois Field,
				; it is possible to traverse all possible values in the galois field
				; except zero via exponentiation. Numbers for which this is possible
				; are called generators. Rijndael's galois field has the following generators:
				;  03 05 06 09 0B 0E 11 12 13 14 17 18 19 1A 1C 1E 
				;  1F 21 22 23 27 28 2A 2C 30 31 3C 3E 3F 41 45 46 
				;  47 48 49 4B 4C 4E 4F 52 54 56 57 58 59 5A 5B 5F 
				;  64 65 68 69 6D 6E 70 71 76 77 79 7A 7B 7E 81 84 
				;  86 87 88 8A 8E 8F 90 93 95 96 98 99 9B 9D A0 A4 
				;  A5 A6 A7 A9 AA AC AD B2 B4 B7 B8 B9 BA BE BF C0 
				;  C1 C4 C8 C9 CE CF D0 D6 D7 DA DC DD DE E2 E3 E5 
				;  E6 E7 E9 EA EB EE F0 F1 F4 F5 F6 F8 FB FD FE FF
				; When any of these numbers is exponentiated multiple times,
				;  the original number is reached again after 255 exponentiations.
				;
				; Using the log[] table to more quickly multiply numbers
				; https://www.samiam.org/galois.html
				;  Look up 0x03 on the log table. We get 0x08
				;  Look up 0x07 on the log table. We get 0x36
				;  Add up these two numbers together (using normal, not Galois Field, addition)
				;   mod 255. 0x08 + 0x36 = 0x3e
				;  Look up the sum, 0x3e, on the exponentiation table. We get 0x09. 
				;
				; Division
				; Dividing x by y in Rijndael's Galois Field is performed by taking 
				; the logarithm of x and subtracting the logarithm of y from it, modulo 255.
				; In particular, when x (the numerator) is 1, division is done by taking
				; the logarithm of x, which can be represented as the number 255,
				; and subtracting the logarithm of y from 255. 
				;
				; Multiplicative inverse
				; 1 divided by a given number is the multiplicative inverse of that number.
				; To find the multiplicative inverse of the number x:
				;    Find the logarithm for x
				;    Subtract 255 by x's logarithm
				;    Take the anti-log of the resulting number
				;    This is the multiplicative inverse (In other words, 1/x) 
				; Example:
				; Code using log and anti-log tables to calculate the multiplicative inverse: 
				; unsigned char gmul_inverse(unsigned char x)
				;   {
				;   if(x == 0) return 0;                 // 0 is self inverting
				;   else return pow[(255 - log[x])];
				;   }

				; ---------------
				; Generator: 0x03      GF(256)
				; ---------------
				; log[] table:
				;    | 0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
				; ---|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|
				; 00 |-- 00 19 01 32 02 1a c6 4b c7 1b 68 33 ee df 03 
				; 10 |64 04 e0 0e 34 8d 81 ef 4c 71 08 c8 f8 69 1c c1 
				; 20 |7d c2 1d b5 f9 b9 27 6a 4d e4 a6 72 9a c9 09 78 
				; 30 |65 2f 8a 05 21 0f e1 24 12 f0 82 45 35 93 da 8e 
				; 40 |96 8f db bd 36 d0 ce 94 13 5c d2 f1 40 46 83 38 
				; 50 |66 dd fd 30 bf 06 8b 62 b3 25 e2 98 22 88 91 10 
				; 60 |7e 6e 48 c3 a3 b6 1e 42 3a 6b 28 54 fa 85 3d ba 
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 9 - 1


				; 70 |2b 79 0a 15 9b 9f 5e ca 4e d4 ac e5 f3 73 a7 57 
				; 80 |af 58 a8 50 f4 ea d6 74 4f ae e9 d5 e7 e6 ad e8 
				; 90 |2c d7 75 7a eb 16 0b f5 59 cb 5f b0 9c a9 51 a0 
				; a0 |7f 0c f6 6f 17 c4 49 ec d8 43 1f 2d a4 76 7b b7 
				; b0 |cc bb 3e 5a fb 60 b1 86 3b 52 a1 6c aa 55 29 9d 
				; c0 |97 b2 87 90 61 be dc fc bc 95 cf cd 37 3f 5b d1 
				; d0 |53 39 84 3c 41 a2 6d 47 14 2a 9e 5d 56 f2 d3 ab 
				; e0 |44 11 92 d9 23 20 2e 89 b4 7c b8 26 77 99 e3 a5 
				; f0 |67 4a ed de c5 31 fe 18 0d 63 8c 80 c0 f7 70 07 
				; 
				; pow[] table:
				;    | 0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
				; ---|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|
				; 00 |01 03 05 0f 11 33 55 ff 1a 2e 72 96 a1 f8 13 35 
				; 10 |5f e1 38 48 d8 73 95 a4 f7 02 06 0a 1e 22 66 aa 
				; 20 |e5 34 5c e4 37 59 eb 26 6a be d9 70 90 ab e6 31 
				; 30 |53 f5 04 0c 14 3c 44 cc 4f d1 68 b8 d3 6e b2 cd 
				; 40 |4c d4 67 a9 e0 3b 4d d7 62 a6 f1 08 18 28 78 88 
				; 50 |83 9e b9 d0 6b bd dc 7f 81 98 b3 ce 49 db 76 9a 
				; 60 |b5 c4 57 f9 10 30 50 f0 0b 1d 27 69 bb d6 61 a3 
				; 70 |fe 19 2b 7d 87 92 ad ec 2f 71 93 ae e9 20 60 a0 
				; 80 |fb 16 3a 4e d2 6d b7 c2 5d e7 32 56 fa 15 3f 41 
				; 90 |c3 5e e2 3d 47 c9 40 c0 5b ed 2c 74 9c bf da 75 
				; a0 |9f ba d5 64 ac ef 2a 7e 82 9d bc df 7a 8e 89 80 
				; b0 |9b b6 c1 58 e8 23 65 af ea 25 6f b1 c8 43 c5 54 
				; c0 |fc 1f 21 63 a5 f4 07 09 1b 2d 77 99 b0 cb 46 ca 
				; d0 |45 cf 4a de 79 8b 86 91 a8 e3 3e 42 c6 51 f3 0e 
				; e0 |12 36 5a ee 29 7b 8d 8c 8f 8a 85 94 a7 f2 0d 17 
				; f0 |39 4b dd 7c 84 97 a2 fd 1c 24 6c b4 c7 52 f6 01
				 
				        ; XTIME(x) ( ( x << 1 ) ^ ( ( x & 0x80 ) ? 0x1B : 0x00 ) )
				        ; for( i = 0, x = 1; i < 256; i++, x ^= XTIME( x ) )
 00000000  55		   *	    push   ebp
 00000001  8B EC	   *	    mov    ebp, esp
 00000003  81 C4 FFFFFDEC  *	    add    esp, 0FFFFFDECh
 00000009  C6 85 FFFFFDEF	        mov      BYTE PTR __x, 1        ; 255 entries in log/pow table
	   01
 00000010  33 C9		        xor      ecx, ecx               ; i = 0;
				        
 00000012			aesGenTab_1:                                          ; Loop #1      ; Loop #2      ; Loop #3
 00000012  0F B6 85		        movzx    eax, BYTE PTR __x                    ; -----------  ; -----------  ; -----------
	   FFFFFDEF
 00000019  88 84 0D		        mov      BYTE PTR _pow[ecx], al ; pow[i] = x;   Pow[0]=0x01    Pow[1]=0x03    Pow[2]=0x05
	   FFFFFE00
 00000020  88 8C 05		        mov      BYTE PTR _log[eax], cl ; log[x] = i;   log[1]=0x00    log[3]=0x01    log[5]=0x02
	   FFFFFF00
 00000027  8B D0		        mov      edx, eax                             ;  edx = 0x01  ;  edx = 0x03  ;  edx = 0x05
 00000029  D1 E2		        shl      edx, 1                               ;  edx = 0x02  ;  edx = 0x06  ;  edx = 0x0A
 0000002B  25 00000080		        and      eax, 80h                             ;  eax = 0x00  ;  eax = 0x00  ;  eax = 0x00
 00000030  F7 D8		        neg      eax       ; 0-eax, CF=1 if eax != 0  ;  eax = 0x00  ;  eax = 0x00  ;  eax = 0x00
 00000032  1B C0		        sbb      eax, eax  ; DEST := (DEST-(SRC+CF))  ;  eax = 0x00  ;  eax = 0x00  ;  eax = 0x00
 00000034  83 E0 1B		        and      eax, 1Bh
 00000037  33 D0		        xor      edx, eax                             ;  edx = 0x02  ;  edx = 0x06  ;  edx = 0x0A
 00000039  0F B6 85		        movzx    eax, BYTE PTR __x                    ;  eax = 0x01  ;  eax = 0x03  ;  eax = 0x05
	   FFFFFDEF
 00000040  33 C2		        xor      eax, edx                             ;  eax = 0x03  ;  eax = 0x05  ;  eax = 0x0F
 00000042  88 85 FFFFFDEF	        mov      BYTE PTR __x, al                     ;  __x = 0x03  ;  __x = 0x05  ;  __x = 0x0F

 00000048  41			        inc      ecx                    ; i++;        ;  ecx = 0x01  ;  ecx = 0x02  ;  ecx = 0x03
 00000049  81 F9 00000100	        cmp      ecx, _SIZE_TABLE       ; =256
 0000004F  72 C1		        jb       SHORT aesGenTab_1
				  
				;// Round constants (fixed by ;;ha;;)
				;static const uint32 RCON[10] =
				;{
				;    0x01000000, 0x02000000, 0x04000000, 0x08000000,    // (01000000 << 1), ..
				;    0x10000000, 0x20000000, 0x40000000, 0x80000000,    // (10000000 << 1), .. 
				;    0x1B000000, 0x36000000                             //  1B000000, (1B000000 << 1)
				;};
				        ; // calculate the round constants
				        ; RCON[i] = (uint32) x << 24;
				        ; XTIME(x) ( ( x << 1 ) ^ ( ( x & 0x80 ) ? 0x1B : 0x00 ) ); // ??
				        ; for( i = 0, x = 1; i < 10; i++, x = XTIME( x ) )
 00000051  C6 85 FFFFFDEF	        mov      BYTE PTR __x, 1
	   01
 00000058  33 C9		        xor      ecx, ecx               ; i=0;

 0000005A			aesGenTab_2:                                            ; Loop #0     ; Loop #7    ; Loop #8    ; Loop #9                          
 0000005A  0F B6 85		        movzx    eax, BYTE PTR __x                      ; ---------   ; ---------  ; ---------  ; ---------
	   FFFFFDEF
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 10 - 1


 00000061  C1 E0 18		        shl      eax, 24                                ;             ;            ;            ;
 00000064  89 04 8D		        mov      DWORD PTR _RCON[ecx*SIZEOF DWORD], eax ; 01000000h   ; 80000000h  ; 1B000000h  ; 36000000h
	   0000340C R
 0000006B  0F B6 85		        movzx    eax, BYTE PTR __x                      ; 00000001h   ; 00000080h  ; 0000001Bh  ; 00000036h
	   FFFFFDEF
 00000072  8B D0		        mov      edx, eax
 00000074  D1 E0		        shl      eax, 1                                 ; 00000002h   ; 00000100h  ; 00000036h  ; 0000006Ch
 00000076  81 E2 00000080	        and      edx, 80h                               ; 00000000h   ; 00000080h  ; 00000000h  ; end-of-loop
 0000007C  F7 DA		        neg      edx      ; 0-edx, CF=1 if edx != 0     ; 00000000h   ; FFFFFF80h  ; 00000000h  
 0000007E  81 E2 1B000000	        and      edx, 1Bh SHL 24                        ; 00000000h   ; 1B000000h  ; 00000000h  
 00000084  33 C2		        xor      eax, edx                               ; 00000002h   ; 1B000100h  ; 00000036h  
 00000086  A9 FF000000		        test     eax, 0FFh SHL 24
 0000008B  74 02		        jz       @F
 0000008D  0F C8		        bswap    eax                                                  ; 0001001Bh  
 0000008F  88 85 FFFFFDEF	@@:     mov      BYTE PTR __x, al                       ; 00000002h   ; 0001001Bh  ; 00000036h

 00000095  41			        inc      ecx                    ; i++;
 00000096  83 F9 0A		        cmp      ecx, _SIZE_ROUND_CONST ; =10
 00000099  72 BF		        jb       SHORT aesGenTab_2

				;// Forward S-box
				;static const uint8 FSb[256] =
				;{
				;    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5,   ; [00]..[07] -> [00]=0x63
				;    0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,   ; [08]..[0F]
				;    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0,
				;    0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
				;    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC,
				;    0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
				;    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A,
				;    0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
				;    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0,
				;    0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
				;    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B,
				;    0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
				;    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85,
				;    0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
				;    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5,
				;    0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
				;    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17,
				;    0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
				;    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88,
				;    0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
				;    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C,
				;    0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
				;    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9,
				;    0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
				;    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6,
				;    0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
				;    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E,
				;    0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
				;    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94,
				;    0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
				;    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68,
				;    0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
				;};
				
				;// Reverse S-box
				;static const uint8 RSb[256] =
				;{
				;    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38,   ; [00]..[07]
				;    0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,   ; [08]..[0F]
				;    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87,   ; [10]..[17]
				;    0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,   ; [18]..[1F]
				;    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D,   ; [20]..[37]
				;    0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,   ; [28]..[3F]
				;    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2,   ; [30]..[47]
				;    0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,   ; [38]..[4F]
				;    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16,   ; [40]..[37]
				;    0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,   ; [48]..[3F]
				;    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA,   ; [50]..[47]
				;    0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,   ; [58]..[4F]
				;    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A,   ; [60]..[67] -> [63]=0x00
				;    0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,   ; [68]..[6F]
				;    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02,
				;    0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
				;    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA,   
				;    0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,   
				;    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85,   
				;    0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,   
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 11 - 1


				;    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89,
				;    0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
				;    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20,
				;    0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
				;    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31,   
				;    0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,   
				;    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D,   
				;    0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,   
				;    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0,
				;    0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
				;    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26,
				;    0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
				;};
				        ; // generate the forward and reverse S-boxes
 0000009B  C6 05 0000320C R	        mov      BYTE PTR _FSb[00h], 63h ; FSb[0x00] = 0x63;
	   63
 000000A2  C6 05 0000336F R	        mov      BYTE PTR _RSb[63h], 0   ; RSb[0x63] = 0x00;
	   00

				        ; for( i = 1; i < 256; i++ )
 000000A9  C7 85 FFFFFDF0	        mov      DWORD PTR __i, 1         
	   00000001

 000000B3			aesGenTab_3:                                                            
				        ; x = pow[(255 - log[i])];
 000000B3  8B 8D FFFFFDF0	        mov      ecx, DWORD PTR __i
 000000B9  0F B6 84 0D		        movzx    eax, BYTE PTR _log[ecx]
	   FFFFFF00
 000000C1  B9 000000FF		        mov      ecx, 255
 000000C6  2B C8		        sub      ecx, eax
 000000C8  0F B6 84 0D		        movzx    eax, BYTE PTR _pow[ecx]
	   FFFFFE00
				         

				        ; y = x; y = ( y << 1 ) | ( y >> 7 );
 000000D0  88 85 FFFFFDEF	        mov      BYTE PTR __x, al       
 000000D6  88 85 FFFFFDEE	        mov      BYTE PTR __y, al
 000000DC  8B D0		        mov      edx, eax         ; y = x
 000000DE  D1 E0		        shl      eax, 1
 000000E0  C1 FA 07		        sar      edx, 7           ; SAR instruction fills the empty bit position’s              
 000000E3  0B C2		        or       eax, edx         ;  shifted value with the sign of the unshifted value
 000000E5  88 85 FFFFFDEE	        mov      BYTE PTR __y, al

 000000EB  B9 00000003		        mov      ecx, 3           ; The same to be performed 3 times
 000000F0			@@:     ; x ^= y; y = ( y << 1 ) | ( y >> 7 );
 000000F0  0F B6 95		        movzx    edx, BYTE PTR __x
	   FFFFFDEF
 000000F7  0F B6 85		        movzx    eax, BYTE PTR __y
	   FFFFFDEE
 000000FE  33 D0		        xor      edx, eax
 00000100  88 95 FFFFFDEF	        mov      BYTE PTR __x, dl
 00000106  8B D0		        mov      edx, eax
 00000108  D1 E0		        shl      eax, 1
 0000010A  C1 FA 07		        sar      edx, 7
 0000010D  0B C2		        or       eax, edx
 0000010F  88 85 FFFFFDEE	        mov      BYTE PTR __y, al
 00000115  E2 D9		        loop     @B

				        ; x ^= y ^ 0x63;
 00000117  0F B6 95		        movzx    edx, BYTE PTR __x
	   FFFFFDEF
 0000011E  0F B6 85		        movzx    eax, BYTE PTR __y
	   FFFFFDEE
 00000125  83 F0 63		        xor      eax, 63h
 00000128  33 D0		        xor      edx, eax
 0000012A  88 95 FFFFFDEF	        mov      BYTE PTR __x, dl

				        ; FSb[i] = x;
 00000130  8A 85 FFFFFDEF	        mov      al, BYTE PTR __x
 00000136  8B 8D FFFFFDF0	        mov      ecx, DWORD PTR __i
 0000013C  88 81 0000320C R	        mov      BYTE PTR _FSb[ecx], al        ; Forward S-box

				        ; RSb[x] = i;
 00000142  8A 85 FFFFFDF0	        mov      al, BYTE PTR __i
 00000148  0F B6 8D		        movzx    ecx, BYTE PTR __x
	   FFFFFDEF
 0000014F  88 81 0000330C R	        mov      BYTE PTR _RSb[ecx], al        ; Reverse S-box

 00000155  FF 85 FFFFFDF0	        inc      DWORD PTR __i
 0000015B  81 BD FFFFFDF0	        cmp      DWORD PTR __i, _SIZE_TABLE    ; =256
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 12 - 1


	   00000100
 00000165  0F 82 FFFFFF48	        jb       aesGenTab_3

				;// Forward tables
				;#define FT \
				;\
				;    V(C6,63,63,A5), V(F8,7C,7C,84), V(EE,77,77,99), V(F6,7B,7B,8D), \           // FT0 
				;    V(FF,F2,F2,0D), V(D6,6B,6B,BD), V(DE,6F,6F,B1), V(91,C5,C5,54), \                  
				;    V(60,30,30,50), V(02,01,01,03), V(CE,67,67,A9), V(56,2B,2B,7D), \                  
				;    V(E7,FE,FE,19), V(B5,D7,D7,62), V(4D,AB,AB,E6), V(EC,76,76,9A), \                  
				;    V(8F,CA,CA,45), V(1F,82,82,9D), V(89,C9,C9,40), V(FA,7D,7D,87), \                  
				;    V(EF,FA,FA,15), V(B2,59,59,EB), V(8E,47,47,C9), V(FB,F0,F0,0B), \                  
				;    V(41,AD,AD,EC), V(B3,D4,D4,67), V(5F,A2,A2,FD), V(45,AF,AF,EA), \                  
				;    V(23,9C,9C,BF), V(53,A4,A4,F7), V(E4,72,72,96), V(9B,C0,C0,5B), \                  
				;    V(75,B7,B7,C2), V(E1,FD,FD,1C), V(3D,93,93,AE), V(4C,26,26,6A), \                  
				;    V(6C,36,36,5A), V(7E,3F,3F,41), V(F5,F7,F7,02), V(83,CC,CC,4F), \                  
				;    V(68,34,34,5C), V(51,A5,A5,F4), V(D1,E5,E5,34), V(F9,F1,F1,08), \                  
				;    V(E2,71,71,93), V(AB,D8,D8,73), V(62,31,31,53), V(2A,15,15,3F), \                  
				;    V(08,04,04,0C), V(95,C7,C7,52), V(46,23,23,65), V(9D,C3,C3,5E), \                  
				;    V(30,18,18,28), V(37,96,96,A1), V(0A,05,05,0F), V(2F,9A,9A,B5), \                  
				;    V(0E,07,07,09), V(24,12,12,36), V(1B,80,80,9B), V(DF,E2,E2,3D), \                  
				;    V(CD,EB,EB,26), V(4E,27,27,69), V(7F,B2,B2,CD), V(EA,75,75,9F), \                  
				;
				;    V(12,09,09,1B), V(1D,83,83,9E), V(58,2C,2C,74), V(34,1A,1A,2E), \           // FT1 
				;    V(36,1B,1B,2D), V(DC,6E,6E,B2), V(B4,5A,5A,EE), V(5B,A0,A0,FB), \                  
				;    V(A4,52,52,F6), V(76,3B,3B,4D), V(B7,D6,D6,61), V(7D,B3,B3,CE), \                  
				;    V(52,29,29,7B), V(DD,E3,E3,3E), V(5E,2F,2F,71), V(13,84,84,97), \                  
				;    V(A6,53,53,F5), V(B9,D1,D1,68), V(00,00,00,00), V(C1,ED,ED,2C), \                  
				;    V(40,20,20,60), V(E3,FC,FC,1F), V(79,B1,B1,C8), V(B6,5B,5B,ED), \                  
				;    V(D4,6A,6A,BE), V(8D,CB,CB,46), V(67,BE,BE,D9), V(72,39,39,4B), \                  
				;    V(94,4A,4A,DE), V(98,4C,4C,D4), V(B0,58,58,E8), V(85,CF,CF,4A), \                  
				;    V(BB,D0,D0,6B), V(C5,EF,EF,2A), V(4F,AA,AA,E5), V(ED,FB,FB,16), \                  
				;    V(86,43,43,C5), V(9A,4D,4D,D7), V(66,33,33,55), V(11,85,85,94), \                  
				;    V(8A,45,45,CF), V(E9,F9,F9,10), V(04,02,02,06), V(FE,7F,7F,81), \                  
				;    V(A0,50,50,F0), V(78,3C,3C,44), V(25,9F,9F,BA), V(4B,A8,A8,E3), \                  
				;    V(A2,51,51,F3), V(5D,A3,A3,FE), V(80,40,40,C0), V(05,8F,8F,8A), \                  
				;    V(3F,92,92,AD), V(21,9D,9D,BC), V(70,38,38,48), V(F1,F5,F5,04), \                  
				;    V(63,BC,BC,DF), V(77,B6,B6,C1), V(AF,DA,DA,75), V(42,21,21,63), \                  
				;    V(20,10,10,30), V(E5,FF,FF,1A), V(FD,F3,F3,0E), V(BF,D2,D2,6D), \                  
				;    
				;    V(81,CD,CD,4C), V(18,0C,0C,14), V(26,13,13,35), V(C3,EC,EC,2F), \           // FT2 
				;    V(BE,5F,5F,E1), V(35,97,97,A2), V(88,44,44,CC), V(2E,17,17,39), \                  
				;    V(93,C4,C4,57), V(55,A7,A7,F2), V(FC,7E,7E,82), V(7A,3D,3D,47), \                  
				;    V(C8,64,64,AC), V(BA,5D,5D,E7), V(32,19,19,2B), V(E6,73,73,95), \                  
				;    V(C0,60,60,A0), V(19,81,81,98), V(9E,4F,4F,D1), V(A3,DC,DC,7F), \                  
				;    V(44,22,22,66), V(54,2A,2A,7E), V(3B,90,90,AB), V(0B,88,88,83), \                  
				;    V(8C,46,46,CA), V(C7,EE,EE,29), V(6B,B8,B8,D3), V(28,14,14,3C), \                  
				;    V(A7,DE,DE,79), V(BC,5E,5E,E2), V(16,0B,0B,1D), V(AD,DB,DB,76), \                  
				;    V(DB,E0,E0,3B), V(64,32,32,56), V(74,3A,3A,4E), V(14,0A,0A,1E), \                  
				;    V(92,49,49,DB), V(0C,06,06,0A), V(48,24,24,6C), V(B8,5C,5C,E4), \                  
				;    V(9F,C2,C2,5D), V(BD,D3,D3,6E), V(43,AC,AC,EF), V(C4,62,62,A6), \                  
				;    V(39,91,91,A8), V(31,95,95,A4), V(D3,E4,E4,37), V(F2,79,79,8B), \                  
				;    V(D5,E7,E7,32), V(8B,C8,C8,43), V(6E,37,37,59), V(DA,6D,6D,B7), \                  
				;    V(01,8D,8D,8C), V(B1,D5,D5,64), V(9C,4E,4E,D2), V(49,A9,A9,E0), \                  
				;    V(D8,6C,6C,B4), V(AC,56,56,FA), V(F3,F4,F4,07), V(CF,EA,EA,25), \                  
				;    V(CA,65,65,AF), V(F4,7A,7A,8E), V(47,AE,AE,E9), V(10,08,08,18), \                  
				;
				;    V(6F,BA,BA,D5), V(F0,78,78,88), V(4A,25,25,6F), V(5C,2E,2E,72), \           // FT3 
				;    V(38,1C,1C,24), V(57,A6,A6,F1), V(73,B4,B4,C7), V(97,C6,C6,51), \                  
				;    V(CB,E8,E8,23), V(A1,DD,DD,7C), V(E8,74,74,9C), V(3E,1F,1F,21), \                  
				;    V(96,4B,4B,DD), V(61,BD,BD,DC), V(0D,8B,8B,86), V(0F,8A,8A,85), \                  
				;    V(E0,70,70,90), V(7C,3E,3E,42), V(71,B5,B5,C4), V(CC,66,66,AA), \                  
				;    V(90,48,48,D8), V(06,03,03,05), V(F7,F6,F6,01), V(1C,0E,0E,12), \                  
				;    V(C2,61,61,A3), V(6A,35,35,5F), V(AE,57,57,F9), V(69,B9,B9,D0), \                  
				;    V(17,86,86,91), V(99,C1,C1,58), V(3A,1D,1D,27), V(27,9E,9E,B9), \                  
				;    V(D9,E1,E1,38), V(EB,F8,F8,13), V(2B,98,98,B3), V(22,11,11,33), \                  
				;    V(D2,69,69,BB), V(A9,D9,D9,70), V(07,8E,8E,89), V(33,94,94,A7), \                  
				;    V(2D,9B,9B,B6), V(3C,1E,1E,22), V(15,87,87,92), V(C9,E9,E9,20), \                  
				;    V(87,CE,CE,49), V(AA,55,55,FF), V(50,28,28,78), V(A5,DF,DF,7A), \                  
				;    V(03,8C,8C,8F), V(59,A1,A1,F8), V(09,89,89,80), V(1A,0D,0D,17), \                  
				;    V(65,BF,BF,DA), V(D7,E6,E6,31), V(84,42,42,C6), V(D0,68,68,B8), \                  
				;    V(82,41,41,C3), V(29,99,99,B0), V(5A,2D,2D,77), V(1E,0F,0F,11), \                  
				;    V(7B,B0,B0,CB), V(A8,54,54,FC), V(6D,BB,BB,D6), V(2C,16,16,3A)                             

				;// Reverse tables
				;#define RT \
				;\
				;    V(51,F4,A7,50), V(7E,41,65,53), V(1A,17,A4,C3), V(3A,27,5E,96), \           // RT0         
				;    V(3B,AB,6B,CB), V(1F,9D,45,F1), V(AC,FA,58,AB), V(4B,E3,03,93), \                          
				;    V(20,30,FA,55), V(AD,76,6D,F6), V(88,CC,76,91), V(F5,02,4C,25), \                          
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 13 - 1


				;    V(4F,E5,D7,FC), V(C5,2A,CB,D7), V(26,35,44,80), V(B5,62,A3,8F), \                          
				;    V(DE,B1,5A,49), V(25,BA,1B,67), V(45,EA,0E,98), V(5D,FE,C0,E1), \                          
				;    V(C3,2F,75,02), V(81,4C,F0,12), V(8D,46,97,A3), V(6B,D3,F9,C6), \                          
				;    V(03,8F,5F,E7), V(15,92,9C,95), V(BF,6D,7A,EB), V(95,52,59,DA), \                          
				;    V(D4,BE,83,2D), V(58,74,21,D3), V(49,E0,69,29), V(8E,C9,C8,44), \                          
				;    V(75,C2,89,6A), V(F4,8E,79,78), V(99,58,3E,6B), V(27,B9,71,DD), \                          
				;    V(BE,E1,4F,B6), V(F0,88,AD,17), V(C9,20,AC,66), V(7D,CE,3A,B4), \                          
				;    V(63,DF,4A,18), V(E5,1A,31,82), V(97,51,33,60), V(62,53,7F,45), \                          
				;    V(B1,64,77,E0), V(BB,6B,AE,84), V(FE,81,A0,1C), V(F9,08,2B,94), \                          
				;    V(70,48,68,58), V(8F,45,FD,19), V(94,DE,6C,87), V(52,7B,F8,B7), \                          
				;    V(AB,73,D3,23), V(72,4B,02,E2), V(E3,1F,8F,57), V(66,55,AB,2A), \                          
				;    V(B2,EB,28,07), V(2F,B5,C2,03), V(86,C5,7B,9A), V(D3,37,08,A5), \                          
				;    V(30,28,87,F2), V(23,BF,A5,B2), V(02,03,6A,BA), V(ED,16,82,5C), \                          
				;
				;    V(8A,CF,1C,2B), V(A7,79,B4,92), V(F3,07,F2,F0), V(4E,69,E2,A1), \           // RT1         
				;    V(65,DA,F4,CD), V(06,05,BE,D5), V(D1,34,62,1F), V(C4,A6,FE,8A), \                          
				;    V(34,2E,53,9D), V(A2,F3,55,A0), V(05,8A,E1,32), V(A4,F6,EB,75), \                          
				;    V(0B,83,EC,39), V(40,60,EF,AA), V(5E,71,9F,06), V(BD,6E,10,51), \                          
				;    V(3E,21,8A,F9), V(96,DD,06,3D), V(DD,3E,05,AE), V(4D,E6,BD,46), \                          
				;    V(91,54,8D,B5), V(71,C4,5D,05), V(04,06,D4,6F), V(60,50,15,FF), \                          
				;    V(19,98,FB,24), V(D6,BD,E9,97), V(89,40,43,CC), V(67,D9,9E,77), \                          
				;    V(B0,E8,42,BD), V(07,89,8B,88), V(E7,19,5B,38), V(79,C8,EE,DB), \                          
				;    V(A1,7C,0A,47), V(7C,42,0F,E9), V(F8,84,1E,C9), V(00,00,00,00), \                          
				;    V(09,80,86,83), V(32,2B,ED,48), V(1E,11,70,AC), V(6C,5A,72,4E), \                          
				;    V(FD,0E,FF,FB), V(0F,85,38,56), V(3D,AE,D5,1E), V(36,2D,39,27), \                          
				;    V(0A,0F,D9,64), V(68,5C,A6,21), V(9B,5B,54,D1), V(24,36,2E,3A), \                          
				;    V(0C,0A,67,B1), V(93,57,E7,0F), V(B4,EE,96,D2), V(1B,9B,91,9E), \                          
				;    V(80,C0,C5,4F), V(61,DC,20,A2), V(5A,77,4B,69), V(1C,12,1A,16), \                          
				;    V(E2,93,BA,0A), V(C0,A0,2A,E5), V(3C,22,E0,43), V(12,1B,17,1D), \                          
				;    V(0E,09,0D,0B), V(F2,8B,C7,AD), V(2D,B6,A8,B9), V(14,1E,A9,C8), \                          
				;
				;    V(57,F1,19,85), V(AF,75,07,4C), V(EE,99,DD,BB), V(A3,7F,60,FD), \           // RT2         
				;    V(F7,01,26,9F), V(5C,72,F5,BC), V(44,66,3B,C5), V(5B,FB,7E,34), \                          
				;    V(8B,43,29,76), V(CB,23,C6,DC), V(B6,ED,FC,68), V(B8,E4,F1,63), \                          
				;    V(D7,31,DC,CA), V(42,63,85,10), V(13,97,22,40), V(84,C6,11,20), \                          
				;    V(85,4A,24,7D), V(D2,BB,3D,F8), V(AE,F9,32,11), V(C7,29,A1,6D), \                          
				;    V(1D,9E,2F,4B), V(DC,B2,30,F3), V(0D,86,52,EC), V(77,C1,E3,D0), \                          
				;    V(2B,B3,16,6C), V(A9,70,B9,99), V(11,94,48,FA), V(47,E9,64,22), \                          
				;    V(A8,FC,8C,C4), V(A0,F0,3F,1A), V(56,7D,2C,D8), V(22,33,90,EF), \                          
				;    V(87,49,4E,C7), V(D9,38,D1,C1), V(8C,CA,A2,FE), V(98,D4,0B,36), \                          
				;    V(A6,F5,81,CF), V(A5,7A,DE,28), V(DA,B7,8E,26), V(3F,AD,BF,A4), \                          
				;    V(2C,3A,9D,E4), V(50,78,92,0D), V(6A,5F,CC,9B), V(54,7E,46,62), \                          
				;    V(F6,8D,13,C2), V(90,D8,B8,E8), V(2E,39,F7,5E), V(82,C3,AF,F5), \                          
				;    V(9F,5D,80,BE), V(69,D0,93,7C), V(6F,D5,2D,A9), V(CF,25,12,B3), \                          
				;    V(C8,AC,99,3B), V(10,18,7D,A7), V(E8,9C,63,6E), V(DB,3B,BB,7B), \                          
				;    V(CD,26,78,09), V(6E,59,18,F4), V(EC,9A,B7,01), V(83,4F,9A,A8), \                          
				;    V(E6,95,6E,65), V(AA,FF,E6,7E), V(21,BC,CF,08), V(EF,15,E8,E6), \                          
				;
				;    V(BA,E7,9B,D9), V(4A,6F,36,CE), V(EA,9F,09,D4), V(29,B0,7C,D6), \           // RT3         
				;    V(31,A4,B2,AF), V(2A,3F,23,31), V(C6,A5,94,30), V(35,A2,66,C0), \                          
				;    V(74,4E,BC,37), V(FC,82,CA,A6), V(E0,90,D0,B0), V(33,A7,D8,15), \                          
				;    V(F1,04,98,4A), V(41,EC,DA,F7), V(7F,CD,50,0E), V(17,91,F6,2F), \                          
				;    V(76,4D,D6,8D), V(43,EF,B0,4D), V(CC,AA,4D,54), V(E4,96,04,DF), \                          
				;    V(9E,D1,B5,E3), V(4C,6A,88,1B), V(C1,2C,1F,B8), V(46,65,51,7F), \                          
				;    V(9D,5E,EA,04), V(01,8C,35,5D), V(FA,87,74,73), V(FB,0B,41,2E), \                          
				;    V(B3,67,1D,5A), V(92,DB,D2,52), V(E9,10,56,33), V(6D,D6,47,13), \                          
				;    V(9A,D7,61,8C), V(37,A1,0C,7A), V(59,F8,14,8E), V(EB,13,3C,89), \                          
				;    V(CE,A9,27,EE), V(B7,61,C9,35), V(E1,1C,E5,ED), V(7A,47,B1,3C), \                          
				;    V(9C,D2,DF,59), V(55,F2,73,3F), V(18,14,CE,79), V(73,C7,37,BF), \                          
				;    V(53,F7,CD,EA), V(5F,FD,AA,5B), V(DF,3D,6F,14), V(78,44,DB,86), \                          
				;    V(CA,AF,F3,81), V(B9,68,C4,3E), V(38,24,34,2C), V(C2,A3,40,5F), \                          
				;    V(16,1D,C3,72), V(BC,E2,25,0C), V(28,3C,49,8B), V(FF,0D,95,41), \                          
				;    V(39,A8,01,71), V(08,0C,B3,DE), V(D8,B4,E4,9C), V(64,56,C1,90), \                          
				;    V(7B,CB,84,61), V(D5,32,B6,70), V(48,6C,5C,74), V(D0,B8,57,42)                                     

				        ; // generate the forward and reverse tables
				        ; for( i = 0; i < 256; i++ )
 0000016B  C7 85 FFFFFDF0	        mov      DWORD PTR __i, 0
	   00000000

 00000175			aesGenTab_4:
				        ; XTIME(x) ( ( x << 1 ) ^ ( ( x & 0x80 ) ? 0x1B : 0x00 ) );
				        ; x = FSb[i]; y = XTIME( x );
 00000175  8B 8D FFFFFDF0	        mov      ecx, DWORD PTR __i
 0000017B  0F B6 89		        movzx    ecx, BYTE PTR _FSb[ecx]
	   0000320C R
 00000182  88 8D FFFFFDEF	        mov      BYTE PTR __x, cl
 00000188  8B C1		        mov      eax, ecx
 0000018A  81 E1 00000080	        and      ecx, 80h
 00000190  F7 D9		        neg      ecx
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 14 - 1


 00000192  1B C9		        sbb      ecx, ecx
 00000194  83 E1 1B		        and      ecx, 1Bh
 00000197  D1 E0		        shl      eax, 1
 00000199  33 C1		        xor      eax, ecx
 0000019B  88 85 FFFFFDEE	        mov      BYTE PTR __y, al

				        ; FT0[i] =   (uint32) ( x ^ y ) ^
				        ;          ( (uint32) x <<  8 ) ^
				        ;          ( (uint32) x << 16 ) ^
				        ;          ( (uint32) y << 24 );
 000001A1  0F B6 95		        movzx    edx, BYTE PTR __x
	   FFFFFDEF
 000001A8  0F B6 85		        movzx    eax, BYTE PTR __y
	   FFFFFDEE
 000001AF  33 D0		        xor      edx, eax
 000001B1  0F B6 8D		        movzx    ecx, BYTE PTR __x
	   FFFFFDEF
 000001B8  C1 E1 08		        shl      ecx, 8                ; << 8
 000001BB  33 D1		        xor      edx, ecx
 000001BD  C1 E1 08		        shl      ecx, 8                ; << 16
 000001C0  33 D1		        xor      edx, ecx
 000001C2  C1 E0 18		        shl      eax, 24
 000001C5  33 D0		        xor      edx, eax
 000001C7  8B 8D FFFFFDF0	        mov      ecx, DWORD PTR __i                     ; ecx = i
 000001CD  89 14 8D		        mov      DWORD PTR _FT0[ecx*SIZEOF DWORD], edx  ; FT0[i]
	   00001E0C R

				        ; FT1[i] = ROTR8( FT0[i] );
				        AES_ROTATE_I _FT0, _FT1
 000001D4  8B 14 8D	     1	        mov      edx, DWORD PTR _FT0[ecx*SIZEOF DWORD]
	   00001E0C R
 000001DB  C1 E2 18	     1	        shl      edx, 24
 000001DE  8B 04 8D	     1	        mov      eax, DWORD PTR _FT0[ecx*SIZEOF DWORD]
	   00001E0C R
 000001E5  C1 E8 08	     1	        shr      eax, 8
 000001E8  0B D0	     1	        or       edx, eax
 000001EA  89 14 8D	     1	        mov      DWORD PTR _FT1[ecx*SIZEOF DWORD], edx   ; RT1[i]
	   00001A0C R
				        ; FT2[i] = ROTR8( FT1[i] );
				        AES_ROTATE_I _FT1, _FT2
 000001F1  8B 14 8D	     1	        mov      edx, DWORD PTR _FT1[ecx*SIZEOF DWORD]
	   00001A0C R
 000001F8  C1 E2 18	     1	        shl      edx, 24
 000001FB  8B 04 8D	     1	        mov      eax, DWORD PTR _FT1[ecx*SIZEOF DWORD]
	   00001A0C R
 00000202  C1 E8 08	     1	        shr      eax, 8
 00000205  0B D0	     1	        or       edx, eax
 00000207  89 14 8D	     1	        mov      DWORD PTR _FT2[ecx*SIZEOF DWORD], edx   ; RT1[i]
	   0000160C R
				        ; FT3[i] = ROTR8( FT2[i] );
				        AES_ROTATE_I _FT2, _FT3
 0000020E  8B 14 8D	     1	        mov      edx, DWORD PTR _FT2[ecx*SIZEOF DWORD]
	   0000160C R
 00000215  C1 E2 18	     1	        shl      edx, 24
 00000218  8B 04 8D	     1	        mov      eax, DWORD PTR _FT2[ecx*SIZEOF DWORD]
	   0000160C R
 0000021F  C1 E8 08	     1	        shr      eax, 8
 00000222  0B D0	     1	        or       edx, eax
 00000224  89 14 8D	     1	        mov      DWORD PTR _FT3[ecx*SIZEOF DWORD], edx   ; RT1[i]
	   0000120C R

				        ; y = RSb[i];
 0000022B  8A 91 0000330C R	        mov      dl, BYTE PTR _RSb[ecx]
 00000231  88 95 FFFFFDEE	        mov      BYTE PTR __y, dl

				        ; MUL(i,y) ( ( i && y ) ? pow[(log[i] + log[y]) % 255] : 0 );
 00000237  0F B6 95		        movzx    edx, BYTE PTR __y       ; edx = __y
	   FFFFFDEE
 0000023E  85 D2		        test     edx, edx
 00000240  74 21		        je       SHORT aesGenTab_5       ; Skip MOD(255) calculation if __y == 0
				        
				        AES_DIV_GF 11
 00000242  0F B6 85	     1	        movzx    eax, BYTE PTR _log[11]  ; eax = _log[0x0B], ecx = log[y]
	   FFFFFF0B
 00000249  0F B6 8C 15	     1	        movzx    ecx, BYTE PTR _log[edx] ; The CDQ instruction
	   FFFFFF00
 00000251  03 C1	     1	        add      eax, ecx                ;  copies the sign (bit 31) of the value in the EAX register
 00000253  99		     1	        cdq                              ;   into every bit position in the EDX register [edx::eax].
 00000254  B9 000000FF	     1	        mov      ecx, 255                ; IDIV divides the (signed) value in the [edx::eax]
 00000259  F7 F9	     1	        idiv     ecx                     ;  by operand (divisor) - result in the [edx::eax] registers.
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 15 - 1


 0000025B  0F B6 94 15	     1	        movzx    edx, BYTE PTR _pow[edx] ; pow[(log[i] + log[y]) % 255];  
	   FFFFFE00

 00000263			aesGenTab_5:
 00000263  89 95 FFFFFDF4	        mov      DWORD PTR _tv3, edx
 00000269  0F B6 95		        movzx    edx, BYTE PTR __y
	   FFFFFDEE
 00000270  85 D2		        test     edx, edx
 00000272  74 21		        je       SHORT aesGenTab_6
				        
				        AES_DIV_GF 13
 00000274  0F B6 85	     1	        movzx    eax, BYTE PTR _log[13]  ; eax = _log[0x0B], ecx = log[y]
	   FFFFFF0D
 0000027B  0F B6 8C 15	     1	        movzx    ecx, BYTE PTR _log[edx] ; The CDQ instruction
	   FFFFFF00
 00000283  03 C1	     1	        add      eax, ecx                ;  copies the sign (bit 31) of the value in the EAX register
 00000285  99		     1	        cdq                              ;   into every bit position in the EDX register [edx::eax].
 00000286  B9 000000FF	     1	        mov      ecx, 255                ; IDIV divides the (signed) value in the [edx::eax]
 0000028B  F7 F9	     1	        idiv     ecx                     ;  by operand (divisor) - result in the [edx::eax] registers.
 0000028D  0F B6 94 15	     1	        movzx    edx, BYTE PTR _pow[edx] ; pow[(log[i] + log[y]) % 255];  
	   FFFFFE00

 00000295			aesGenTab_6:
 00000295  89 95 FFFFFDF8	        mov      DWORD PTR _tv2, edx
 0000029B  0F B6 95		        movzx    edx, BYTE PTR __y
	   FFFFFDEE
 000002A2  85 D2		        test     edx, edx
 000002A4  74 21		        je       SHORT aesGenTab_7
				        
				        AES_DIV_GF 09
 000002A6  0F B6 85	     1	        movzx    eax, BYTE PTR _log[09]  ; eax = _log[0x0B], ecx = log[y]
	   FFFFFF09
 000002AD  0F B6 8C 15	     1	        movzx    ecx, BYTE PTR _log[edx] ; The CDQ instruction
	   FFFFFF00
 000002B5  03 C1	     1	        add      eax, ecx                ;  copies the sign (bit 31) of the value in the EAX register
 000002B7  99		     1	        cdq                              ;   into every bit position in the EDX register [edx::eax].
 000002B8  B9 000000FF	     1	        mov      ecx, 255                ; IDIV divides the (signed) value in the [edx::eax]
 000002BD  F7 F9	     1	        idiv     ecx                     ;  by operand (divisor) - result in the [edx::eax] registers.
 000002BF  0F B6 94 15	     1	        movzx    edx, BYTE PTR _pow[edx] ; pow[(log[i] + log[y]) % 255];  
	   FFFFFE00

 000002C7			aesGenTab_7:
 000002C7  89 95 FFFFFDFC	        mov      DWORD PTR _tv1, edx
 000002CD  0F B6 95		        movzx    edx, BYTE PTR __y
	   FFFFFDEE
 000002D4  85 D2		        test     edx, edx
 000002D6  74 21		        je       SHORT aesGenTab_8
				  
				        AES_DIV_GF 14
 000002D8  0F B6 85	     1	        movzx    eax, BYTE PTR _log[14]  ; eax = _log[0x0B], ecx = log[y]
	   FFFFFF0E
 000002DF  0F B6 8C 15	     1	        movzx    ecx, BYTE PTR _log[edx] ; The CDQ instruction
	   FFFFFF00
 000002E7  03 C1	     1	        add      eax, ecx                ;  copies the sign (bit 31) of the value in the EAX register
 000002E9  99		     1	        cdq                              ;   into every bit position in the EDX register [edx::eax].
 000002EA  B9 000000FF	     1	        mov      ecx, 255                ; IDIV divides the (signed) value in the [edx::eax]
 000002EF  F7 F9	     1	        idiv     ecx                     ;  by operand (divisor) - result in the [edx::eax] registers.
 000002F1  0F B6 94 15	     1	        movzx    edx, BYTE PTR _pow[edx] ; pow[(log[i] + log[y]) % 255];  
	   FFFFFE00

 000002F9			aesGenTab_8:
				        ; RT0[i] = ( (uint32) MUL( 0x0B, y )       ) ^
				        ;          ( (uint32) MUL( 0x0D, y ) <<  8 ) ^
				        ;          ( (uint32) MUL( 0x09, y ) << 16 ) ^
				        ;          ( (uint32) MUL( 0x0E, y ) << 24 );
 000002F9  8B 85 FFFFFDF4	        mov      eax, DWORD PTR _tv3                     ; _tv2 = _pow[via log[11]]
 000002FF  8B 8D FFFFFDF8	        mov      ecx, DWORD PTR _tv2                     ; _tv1 = _pow[via log[13]]
 00000305  C1 E1 08		        shl      ecx, 8                                  
 00000308  33 C1		        xor      eax, ecx
 0000030A  8B 8D FFFFFDFC	        mov      ecx, DWORD PTR _tv1                     ; _tv3 = _pow[via log[9]]
 00000310  C1 E1 10		        shl      ecx, 16                                 
 00000313  33 C1		        xor      eax, ecx
 00000315  C1 E2 18		        shl      edx, 24                                 ; edx =  _pow[via log[14]]
 00000318  33 C2		        xor      eax, edx
 0000031A  8B 8D FFFFFDF0	        mov      ecx, DWORD PTR __i                      ; ecx = i
 00000320  89 04 8D		        mov      DWORD PTR _RT0[ecx*SIZEOF DWORD], eax   ; RT0[i]
	   0000220C R

				        ; RT1[i] = ROTR8( RT0[i] );
				        AES_ROTATE_I _RT0, _RT1
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 16 - 1


 00000327  8B 14 8D	     1	        mov      edx, DWORD PTR _RT0[ecx*SIZEOF DWORD]
	   0000220C R
 0000032E  C1 E2 18	     1	        shl      edx, 24
 00000331  8B 04 8D	     1	        mov      eax, DWORD PTR _RT0[ecx*SIZEOF DWORD]
	   0000220C R
 00000338  C1 E8 08	     1	        shr      eax, 8
 0000033B  0B D0	     1	        or       edx, eax
 0000033D  89 14 8D	     1	        mov      DWORD PTR _RT1[ecx*SIZEOF DWORD], edx   ; RT1[i]
	   0000260C R
				        ; RT2[i] = ROTR8( RT1[i] );
				        AES_ROTATE_I _RT1, _RT2
 00000344  8B 14 8D	     1	        mov      edx, DWORD PTR _RT1[ecx*SIZEOF DWORD]
	   0000260C R
 0000034B  C1 E2 18	     1	        shl      edx, 24
 0000034E  8B 04 8D	     1	        mov      eax, DWORD PTR _RT1[ecx*SIZEOF DWORD]
	   0000260C R
 00000355  C1 E8 08	     1	        shr      eax, 8
 00000358  0B D0	     1	        or       edx, eax
 0000035A  89 14 8D	     1	        mov      DWORD PTR _RT2[ecx*SIZEOF DWORD], edx   ; RT1[i]
	   00002A0C R
				        ; RT3[i] = ROTR8( RT2[i] );
				        AES_ROTATE_I _RT2, _RT3
 00000361  8B 14 8D	     1	        mov      edx, DWORD PTR _RT2[ecx*SIZEOF DWORD]
	   00002A0C R
 00000368  C1 E2 18	     1	        shl      edx, 24
 0000036B  8B 04 8D	     1	        mov      eax, DWORD PTR _RT2[ecx*SIZEOF DWORD]
	   00002A0C R
 00000372  C1 E8 08	     1	        shr      eax, 8
 00000375  0B D0	     1	        or       edx, eax
 00000377  89 14 8D	     1	        mov      DWORD PTR _RT3[ecx*SIZEOF DWORD], edx   ; RT1[i]
	   00002E0C R

 0000037E  FF 85 FFFFFDF0	        inc      DWORD PTR __i
 00000384  81 BD FFFFFDF0	        cmp      DWORD PTR __i, _SIZE_TABLE
	   00000100
 0000038E  0F 82 FFFFFDE1	        jb       aesGenTab_4
				;       ---------------------
 00000394			aesGenTab_ret:
				        ret
 00000394  C9		   *	    leave  
 00000395  C3		   *	    ret    00000h
 00000396			aesGenerateTables ENDP ; aesGenerateTables


				;------------------------------------------------------------------------------
				;
				;                       aesSetKey
				;
				;   void aes_set_key(aes_context *ctx, uint8 *key, int keysize)
				;
				;   Change: Removed usage of [ebp] to allow "INVOKE" addressing technique.
				;           (the optimizing C++ Compiler froces direct [esp] addresiing
				;            to gain [ebp] as an additional multipurpose register) 
				;
 00000396			aesSetKey PROC C USES ebx esi edi, _ctx:DWORD, _key:DWORD, _keysize:DWORD
				        LOCAL   _SK:DWORD     ; uint32 *SK, *RK;
				        LOCAL   _RK:DWORD     
				        LOCAL   __i:DWORD     ; int i;

 00000396  55		   *	    push   ebp
 00000397  8B EC	   *	    mov    ebp, esp
 00000399  83 C4 F4	   *	    add    esp, 0FFFFFFF4h
 0000039C  53		   *	    push   ebx
 0000039D  56		   *	    push   esi
 0000039E  57		   *	    push   edi
 0000039F  E8 FFFFFC5C		        call     aesGenerateTables

				        ; RK = ctx->erk;
 000003A4  8B 55 08		        mov      edx, DWORD PTR _ctx._ctxStruct.erk ; Encryption round keys
 000003A7  89 55 F8		        mov      DWORD PTR _RK, edx
				        ; switch( keysize )
 000003AA  8B 45 10		        mov      eax, DWORD PTR _keysize
 000003AD  33 C9		        xor      ecx, ecx                       ; Init index counter __i=0

 000003AF			aesSetKey_1:                                
				        ; case 128: ctx->nr = 10; break;
 000003AF  C7 82 00000200	        mov      DWORD PTR [edx]._ctxStruct.rnr, 10
	   0000000A
 000003B9  3D 00000080		        cmp      eax, 128                       ; Keysize 128 bits
 000003BE  74 26		        je       SHORT @F
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 17 - 1


				        
				        ; case 192: ctx->nr = 12; break;
 000003C0  C7 82 00000200	        mov      DWORD PTR [edx]._ctxStruct.rnr, 12
	   0000000C
 000003CA  3D 000000C0		        cmp      eax, 192                       ; Keysize 192 bits
 000003CF  74 15		        je       SHORT @F
				        
				        ; case 256: ctx->nr = 14; break;
 000003D1  C7 82 00000200	        mov      DWORD PTR [edx]._ctxStruct.rnr, 14
	   0000000E
 000003DB  3D 00000100		        cmp      eax, 256                       ; Keysize 256 bits
 000003E0  0F 85 00000400	        jne      aesSetKey_ret                  ; default : return; break;
				        
 000003E6			@@:     ; for( i = 0; i < (keysize >> 5); i++ )
				        ; GET_UINT32_BE( RK[i], key, i << 2 );
 000003E6  8B 55 0C		        mov      edx, DWORD PTR _key
 000003E9  8B 04 8A		        mov      eax, DWORD PTR [edx+ecx*SIZEOF DWORD]    ; ecx = i
 000003EC  0F C8		        bswap    eax
 000003EE  8B 55 F8		        mov      edx, DWORD PTR _RK
 000003F1  89 04 8A		        mov      DWORD PTR [edx+ecx*SIZEOF DWORD], eax
 000003F4  8B 45 10		        mov      eax, DWORD PTR _keysize
 000003F7  C1 E8 05		        shr      eax, 5                         ; i: 4*4, 6*4, 8*4 key-bytes
 000003FA  41			        inc      ecx                            ; ecx = i++;
 000003FB  3B C8		        cmp      ecx, eax
 000003FD  72 E7		        jb       SHORT @B
				;       -----------------

				        ; // setup encryption round keys
				        ; switch( ctx->nr )                    ; edx = ctx
 000003FF  C7 45 F4		        mov      DWORD PTR __i, 0              ; Prepare and init index __i=0
	   00000000
 00000406  8B 4D F8		        mov      ecx, DWORD PTR _RK            ; ecx = RK

 00000409  83 BA 00000200	        cmp      DWORD PTR [edx]._ctxStruct.rnr, 14 ; 256bit-Key: 14 rounds
	   0E
 00000410  0F 84 00000142	        je       aesSetKey_4

 00000416  83 BA 00000200	        cmp      DWORD PTR [edx]._ctxStruct.rnr, 12 ; 192bit-Key: 12 rounds
	   0C
 0000041D  0F 84 00000098	        je       aesSetKey_3

 00000423  83 BA 00000200	        cmp      DWORD PTR [edx]._ctxStruct.rnr, 10 ; 128bit-Key: 10 rounds
	   0A
 0000042A  0F 85 00000219	        jne      aesSetKey_5                        ; Illegal keysize.

 00000430			aesSetKey_2:
				        ; case 10:
				        ;     for( i = 0; i < 10; i++, RK += 4 )
				        ; RK[4]  = RK[0] ^ RCON[i] ^
				        ;     ( FSb[ (uint8) ( RK[3] >> 16 ) ] << 24 ) ^
				        ;     ( FSb[ (uint8) ( RK[3] >>  8 ) ] << 16 ) ^
				        ;     ( FSb[ (uint8) ( RK[3]       ) ] <<  8 ) ^
				        ;     ( FSb[ (uint8) ( RK[3] >> 24 ) ]       );
 00000430  8B 55 F4		        mov      edx, DWORD PTR __i                       ; 128bit-Key: 10 rounds

				        KEYSIZE_SBOX_RCON 3,4                             ; Params: 128/32-1, 128/32
 00000433  8B 01	     1	        mov      eax, DWORD PTR [ecx+0*SIZEOF DWORD]      ; eax = RK[0]
 00000435  33 04 95	     1	        xor      eax, DWORD PTR _RCON[edx*SIZEOF DWORD]   ; RCON[i]
	   0000340C R
 0000043C  8B 51 0C	     1	        mov      edx, DWORD PTR [ecx+3*SIZEOF DWORD]    ; RK[3]
 0000043F  C1 EA 10	     1	        shr      edx, 16
 00000442  0F B6 D2	     1	        movzx    edx, dl
 00000445  0F B6 92	     1	        movzx    edx, BYTE PTR _FSb[edx]
	   0000320C R
 0000044C  C1 E2 18	     1	        shl      edx, 24
 0000044F  33 C2	     1	        xor      eax, edx                                 
 00000451  8B 51 0C	     1	        mov      edx, DWORD PTR [ecx+3*SIZEOF DWORD]    ; RK[3]
 00000454  C1 EA 08	     1	        shr      edx, 8
 00000457  0F B6 D2	     1	        movzx    edx, dl
 0000045A  0F B6 92	     1	        movzx    edx, BYTE PTR _FSb[edx]
	   0000320C R
 00000461  C1 E2 10	     1	        shl      edx, 16
 00000464  33 C2	     1	        xor      eax, edx
 00000466  0F B6 51 0C	     1	        movzx    edx, BYTE PTR [ecx+3*SIZEOF DWORD]     ; RK[3]
 0000046A  0F B6 92	     1	        movzx    edx, BYTE PTR _FSb[edx]
	   0000320C R
 00000471  C1 E2 08	     1	        shl      edx, 8
 00000474  33 C2	     1	        xor      eax, edx
 00000476  8B 51 0C	     1	        mov      edx, DWORD PTR [ecx+3*SIZEOF DWORD]    ; RK[3]
 00000479  C1 EA 18	     1	        shr      edx, 24
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 18 - 1


 0000047C  0F B6 D2	     1	        movzx    edx, dl
 0000047F  0F B6 92	     1	        movzx    edx, BYTE PTR _FSb[edx]
	   0000320C R
 00000486  33 C2	     1	        xor      eax, edx
 00000488  89 41 10	     1	        mov      DWORD PTR [ecx+4*SIZEOF DWORD], eax    ; RK[4] = eax
				                                                          
				        ; RK[5]  = RK[1] ^ RK[4];
 0000048B  8B 41 04		        mov      eax, DWORD PTR [ecx+(1*SIZEOF DWORD)]    ; eax = RK[1]
 0000048E  33 41 10		        xor      eax, DWORD PTR [ecx+(4*SIZEOF DWORD)]
 00000491  89 41 14		        mov      DWORD PTR [ecx+(5*SIZEOF DWORD)], eax    ; RK[5] = eax

				        ; RK[6]  = RK[2] ^ RK[5];
 00000494  8B 41 08		        mov      eax, DWORD PTR [ecx+(2*SIZEOF DWORD)]    ; eax = RK[2]
 00000497  33 41 14		        xor      eax, DWORD PTR [ecx+(5*SIZEOF DWORD)]
 0000049A  89 41 18		        mov      DWORD PTR [ecx+(6*SIZEOF DWORD)], eax    ; RK[6] = eax

				        ; RK[7]  = RK[3] ^ RK[6];
 0000049D  8B 41 0C		        mov      eax, DWORD PTR [ecx+(3*SIZEOF DWORD)]    ; eax = RK[3]
 000004A0  33 41 18		        xor      eax, DWORD PTR [ecx+(6*SIZEOF DWORD)]
 000004A3  89 41 1C		        mov      DWORD PTR [ecx+(7*SIZEOF DWORD)], eax    ; RK[7] = eax

 000004A6  83 C1 10		        add      ecx, 4*SIZEOF DWORD                      ; RK += 4;
 000004A9  FF 45 F4		        inc      DWORD PTR __i                            ; i++;
 000004AC  83 7D F4 0A		        cmp      DWORD PTR __i, _SIZE_ROUND_CONST
 000004B0  0F 82 FFFFFF7A	        jb       aesSetKey_2
				        ; break;
 000004B6  E9 0000018E		        jmp      aesSetKey_5

 000004BB			aesSetKey_3:
				        ; case 12:
				        ;     for( i = 0; i < 8; i++, RK += 6 )
				        ; RK[6]  = RK[0] ^ RCON[i] ^
				        ;     ( FSb[ (uint8) ( RK[5] >> 16 ) ] << 24 ) ^
				        ;     ( FSb[ (uint8) ( RK[5] >>  8 ) ] << 16 ) ^
				        ;     ( FSb[ (uint8) ( RK[5]       ) ] <<  8 ) ^
				        ;     ( FSb[ (uint8) ( RK[5] >> 24 ) ]       );
 000004BB  8B 55 F4		        mov      edx, DWORD PTR __i                       ; 192bit-Key: 12 rounds

				        KEYSIZE_SBOX_RCON 5,6                             ; Params: 192/32-1, 192/32
 000004BE  8B 01	     1	        mov      eax, DWORD PTR [ecx+0*SIZEOF DWORD]      ; eax = RK[0]
 000004C0  33 04 95	     1	        xor      eax, DWORD PTR _RCON[edx*SIZEOF DWORD]   ; RCON[i]
	   0000340C R
 000004C7  8B 51 14	     1	        mov      edx, DWORD PTR [ecx+5*SIZEOF DWORD]    ; RK[3]
 000004CA  C1 EA 10	     1	        shr      edx, 16
 000004CD  0F B6 D2	     1	        movzx    edx, dl
 000004D0  0F B6 92	     1	        movzx    edx, BYTE PTR _FSb[edx]
	   0000320C R
 000004D7  C1 E2 18	     1	        shl      edx, 24
 000004DA  33 C2	     1	        xor      eax, edx                                 
 000004DC  8B 51 14	     1	        mov      edx, DWORD PTR [ecx+5*SIZEOF DWORD]    ; RK[3]
 000004DF  C1 EA 08	     1	        shr      edx, 8
 000004E2  0F B6 D2	     1	        movzx    edx, dl
 000004E5  0F B6 92	     1	        movzx    edx, BYTE PTR _FSb[edx]
	   0000320C R
 000004EC  C1 E2 10	     1	        shl      edx, 16
 000004EF  33 C2	     1	        xor      eax, edx
 000004F1  0F B6 51 14	     1	        movzx    edx, BYTE PTR [ecx+5*SIZEOF DWORD]     ; RK[3]
 000004F5  0F B6 92	     1	        movzx    edx, BYTE PTR _FSb[edx]
	   0000320C R
 000004FC  C1 E2 08	     1	        shl      edx, 8
 000004FF  33 C2	     1	        xor      eax, edx
 00000501  8B 51 14	     1	        mov      edx, DWORD PTR [ecx+5*SIZEOF DWORD]    ; RK[3]
 00000504  C1 EA 18	     1	        shr      edx, 24
 00000507  0F B6 D2	     1	        movzx    edx, dl
 0000050A  0F B6 92	     1	        movzx    edx, BYTE PTR _FSb[edx]
	   0000320C R
 00000511  33 C2	     1	        xor      eax, edx
 00000513  89 41 18	     1	        mov      DWORD PTR [ecx+6*SIZEOF DWORD], eax    ; RK[4] = eax

				        ; RK[7]  = RK[1] ^ RK[6];
 00000516  8B 41 04		        mov      eax, DWORD PTR [ecx+1*SIZEOF DWORD]      ; eax = RK[1]
 00000519  33 41 18		        xor      eax, DWORD PTR [ecx+6*SIZEOF DWORD]
 0000051C  89 41 1C		        mov      DWORD PTR [ecx+7*SIZEOF DWORD], eax      ; RK[7] = eax

				        ; RK[8]  = RK[2] ^ RK[7];
 0000051F  8B 41 08		        mov      eax, DWORD PTR [ecx+2*SIZEOF DWORD]      ; eax = RK[2]
 00000522  33 41 1C		        xor      eax, DWORD PTR [ecx+7*SIZEOF DWORD]
 00000525  89 41 20		        mov      DWORD PTR [ecx+8*SIZEOF DWORD], eax      ; RK[8] = eax

				        ; RK[9]  = RK[3] ^ RK[8];
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 19 - 1


 00000528  8B 41 0C		        mov      eax, DWORD PTR [ecx+3*SIZEOF DWORD]      ; eax = RK[3]
 0000052B  33 41 20		        xor      eax, DWORD PTR [ecx+8*SIZEOF DWORD]
 0000052E  89 41 24		        mov      DWORD PTR [ecx+9*SIZEOF DWORD], eax      ; RK[9] = eax

				        ; RK[10] = RK[4] ^ RK[9];
 00000531  8B 41 10		        mov      eax, DWORD PTR [ecx+4*SIZEOF DWORD]      ; eax = RK[4]
 00000534  33 41 24		        xor      eax, DWORD PTR [ecx+9*SIZEOF DWORD]
 00000537  89 41 28		        mov      DWORD PTR [ecx+10*SIZEOF DWORD], eax     ; RK[10] = eax

				        ; RK[11] = RK[5] ^ RK[10];
 0000053A  8B 41 14		        mov      eax, DWORD PTR [ecx+5*SIZEOF DWORD]      ; eax = RK[5]
 0000053D  33 41 28		        xor      eax, DWORD PTR [ecx+10*SIZEOF DWORD]
 00000540  89 41 2C		        mov      DWORD PTR [ecx+11*SIZEOF DWORD], eax     ; RK[11] = eax

 00000543  83 C1 18		        add      ecx, 6*SIZEOF DWORD                      ; RK += 6;
 00000546  FF 45 F4		        inc      DWORD PTR __i                            ; i++;
 00000549  83 7D F4 08		        cmp      DWORD PTR __i, _SIZE_ROUND_CONST-2       ; =8
 0000054D  0F 82 FFFFFF68	        jb       aesSetKey_3                              ; Loop
				        ; break;
 00000553  E9 000000F1		        jmp      aesSetKey_5                              ; break;
				 
 00000558			aesSetKey_4:                                              ; Keysize 256 bits
				        ; case 14:
				        ;     for( i = 0; i < 7; i++, RK += 8 )
				        ; RK[8]  = RK[0] ^ RCON[i] ^
				        ;     ( FSb[ (uint8) ( RK[7] >> 16 ) ] << 24 ) ^
				        ;     ( FSb[ (uint8) ( RK[7] >>  8 ) ] << 16 ) ^
				        ;     ( FSb[ (uint8) ( RK[7]       ) ] <<  8 ) ^
				        ;     ( FSb[ (uint8) ( RK[7] >> 24 ) ]       );
 00000558  8B 55 F4		        mov      edx, DWORD PTR __i                       ; edx = i

				        KEYSIZE_SBOX_RCON 7,8                             ; Params: 256/32-1, 256/32
 0000055B  8B 01	     1	        mov      eax, DWORD PTR [ecx+0*SIZEOF DWORD]      ; eax = RK[0]
 0000055D  33 04 95	     1	        xor      eax, DWORD PTR _RCON[edx*SIZEOF DWORD]   ; RCON[i]
	   0000340C R
 00000564  8B 51 1C	     1	        mov      edx, DWORD PTR [ecx+7*SIZEOF DWORD]    ; RK[3]
 00000567  C1 EA 10	     1	        shr      edx, 16
 0000056A  0F B6 D2	     1	        movzx    edx, dl
 0000056D  0F B6 92	     1	        movzx    edx, BYTE PTR _FSb[edx]
	   0000320C R
 00000574  C1 E2 18	     1	        shl      edx, 24
 00000577  33 C2	     1	        xor      eax, edx                                 
 00000579  8B 51 1C	     1	        mov      edx, DWORD PTR [ecx+7*SIZEOF DWORD]    ; RK[3]
 0000057C  C1 EA 08	     1	        shr      edx, 8
 0000057F  0F B6 D2	     1	        movzx    edx, dl
 00000582  0F B6 92	     1	        movzx    edx, BYTE PTR _FSb[edx]
	   0000320C R
 00000589  C1 E2 10	     1	        shl      edx, 16
 0000058C  33 C2	     1	        xor      eax, edx
 0000058E  0F B6 51 1C	     1	        movzx    edx, BYTE PTR [ecx+7*SIZEOF DWORD]     ; RK[3]
 00000592  0F B6 92	     1	        movzx    edx, BYTE PTR _FSb[edx]
	   0000320C R
 00000599  C1 E2 08	     1	        shl      edx, 8
 0000059C  33 C2	     1	        xor      eax, edx
 0000059E  8B 51 1C	     1	        mov      edx, DWORD PTR [ecx+7*SIZEOF DWORD]    ; RK[3]
 000005A1  C1 EA 18	     1	        shr      edx, 24
 000005A4  0F B6 D2	     1	        movzx    edx, dl
 000005A7  0F B6 92	     1	        movzx    edx, BYTE PTR _FSb[edx]
	   0000320C R
 000005AE  33 C2	     1	        xor      eax, edx
 000005B0  89 41 20	     1	        mov      DWORD PTR [ecx+8*SIZEOF DWORD], eax    ; RK[4] = eax

				        ; RK[9]  = RK[1] ^ RK[8];
 000005B3  8B 41 04		        mov      eax, DWORD PTR [ecx+1*SIZEOF DWORD]      ; eax = RK[1]
 000005B6  33 41 20		        xor      eax, DWORD PTR [ecx+8*SIZEOF DWORD]
 000005B9  89 41 24		        mov      DWORD PTR [ecx+9*SIZEOF DWORD], eax      ; RK[9] = eax

				        ; RK[10] = RK[2] ^ RK[9];
 000005BC  8B 41 08		        mov      eax, DWORD PTR [ecx+2*SIZEOF DWORD]      ; eax = RK[2]
 000005BF  33 41 24		        xor      eax, DWORD PTR [ecx+9*SIZEOF DWORD]
 000005C2  89 41 28		        mov      DWORD PTR [ecx+10*SIZEOF DWORD], eax     ; RK[10] = eax

				        ; RK[11] = RK[3] ^ RK[10];
 000005C5  8B 41 0C		        mov      eax, DWORD PTR [ecx+3*SIZEOF DWORD]      ; eax = RK[3]
 000005C8  33 41 28		        xor      eax, DWORD PTR [ecx+10*SIZEOF DWORD]
 000005CB  89 41 2C		        mov      DWORD PTR [ecx+11*SIZEOF DWORD], eax     ; RK[11] = eax

				        ; RK[12] = RK[4] ^
				        ;     ( FSb[ (uint8) ( RK[11] >> 24 ) ] << 24 ) ^
				        ;     ( FSb[ (uint8) ( RK[11] >> 16 ) ] << 16 ) ^
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 20 - 1


				        ;     ( FSb[ (uint8) ( RK[11] >>  8 ) ] <<  8 ) ^
				        ;     ( FSb[ (uint8) ( RK[11]       ) ]       );
 000005CE  8B 51 2C		        mov      edx, DWORD PTR [ecx+11*SIZEOF DWORD]     ; RK[11]
 000005D1  C1 EA 18		        shr      edx, 24
 000005D4  0F B6 D2		        movzx    edx, dl
 000005D7  0F B6 82		        movzx    eax, BYTE PTR _FSb[edx]
	   0000320C R
 000005DE  C1 E0 18		        shl      eax, 24
 000005E1  33 41 10		        xor      eax, DWORD PTR [ecx+4*SIZEOF DWORD]      ; RK[4]
 000005E4  8B 51 2C		        mov      edx, DWORD PTR [ecx+11*SIZEOF DWORD]     ; RK[11]
 000005E7  C1 EA 10		        shr      edx, 16
 000005EA  0F B6 D2		        movzx    edx, dl
 000005ED  0F B6 92		        movzx    edx, BYTE PTR _FSb[edx]
	   0000320C R
 000005F4  C1 E2 10		        shl      edx, 16
 000005F7  33 C2		        xor      eax, edx
 000005F9  8B 51 2C		        mov      edx, DWORD PTR [ecx+11*SIZEOF DWORD]     ; RK[11]
 000005FC  C1 EA 08		        shr      edx, 8
 000005FF  0F B6 D2		        movzx    edx, dl
 00000602  0F B6 92		        movzx    edx, BYTE PTR _FSb[edx]
	   0000320C R
 00000609  C1 E2 08		        shl      edx, 8
 0000060C  33 C2		        xor      eax, edx
 0000060E  0F B6 51 2C		        movzx    edx, BYTE PTR [ecx+11*SIZEOF DWORD]      ; RK[11]
 00000612  0F B6 92		        movzx    edx, BYTE PTR _FSb[edx]
	   0000320C R
 00000619  33 C2		        xor      eax, edx
 0000061B  89 41 30		        mov      DWORD PTR [ecx+12*SIZEOF DWORD], eax     ; RK[12]

				        ; RK[13] = RK[5] ^ RK[12];
 0000061E  8B 41 14		        mov      eax, DWORD PTR [ecx+5*SIZEOF DWORD]      ; eax = RK[5]
 00000621  33 41 30		        xor      eax, DWORD PTR [ecx+12*SIZEOF DWORD]
 00000624  89 41 34		        mov      DWORD PTR [ecx+13*SIZEOF DWORD], eax     ; RK[13] = eax

				        ; RK[14] = RK[6] ^ RK[13];
 00000627  8B 41 18		        mov      eax, DWORD PTR [ecx+6*SIZEOF DWORD]      ; eax = RK[6]
 0000062A  33 41 34		        xor      eax, DWORD PTR [ecx+13*SIZEOF DWORD]
 0000062D  89 41 38		        mov      DWORD PTR [ecx+14*SIZEOF DWORD], eax     ; RK[14] = eax

				        ; RK[15] = RK[7] ^ RK[14];
 00000630  8B 41 1C		        mov      eax, DWORD PTR [ecx+7*SIZEOF DWORD]      ; eax = RK[7]
 00000633  33 41 38		        xor      eax, DWORD PTR [ecx+14*SIZEOF DWORD]     
 00000636  89 41 3C		        mov      DWORD PTR [ecx+15*SIZEOF DWORD], eax     ; RK[15] = eax

 00000639  83 C1 20		        add      ecx, 8*SIZEOF DWORD                      ; RK += 8;
 0000063C  FF 45 F4		        inc      DWORD PTR __i                            ; i++;
 0000063F  83 7D F4 07		        cmp      DWORD PTR __i, _SIZE_ROUND_CONST-3       ; =7
 00000643  0F 82 FFFFFF0F	        jb       aesSetKey_4
				;       --------------------

 00000649			aesSetKey_5:
				        ; default:
				        ; // setup decryption round keys
				        ; for( i = 0; i < 256; i++ )
 00000649  33 D2		        xor      edx, edx                                 ; edx: i = 0;

 0000064B			aesSetKey_6:
 0000064B  0F B6 9A		        movzx    ebx, BYTE PTR _FSb[edx]                  ; ebx = FSb[i]
	   0000320C R

				        ; KT0[i] = RT0[ FSb[i] ];
 00000652  8B 04 9D		        mov      eax, DWORD PTR _RT0[ebx*SIZEOF DWORD]    
	   0000220C R
 00000659  89 04 95		        mov      DWORD PTR _KT0[edx*SIZEOF DWORD], eax
	   00000E0C R
				        ; KT1[i] = RT1[ FSb[i] ];
 00000660  8B 04 9D		        mov      eax, DWORD PTR _RT1[ebx*SIZEOF DWORD]
	   0000260C R
 00000667  89 04 95		        mov      DWORD PTR _KT1[edx*SIZEOF DWORD], eax
	   00000A0C R
				        ; KT2[i] = RT2[ FSb[i] ];
 0000066E  8B 04 9D		        mov      eax, DWORD PTR _RT2[ebx*SIZEOF DWORD]
	   00002A0C R
 00000675  89 04 95		        mov      DWORD PTR _KT2[edx*SIZEOF DWORD], eax
	   0000060C R
				        ; KT3[i] = RT3[ FSb[i] ];
 0000067C  8B 04 9D		        mov      eax, DWORD PTR _RT3[ebx*SIZEOF DWORD]
	   00002E0C R
 00000683  89 04 95		        mov      DWORD PTR _KT3[edx*SIZEOF DWORD], eax
	   0000020C R
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 21 - 1


				 
 0000068A  42			        inc      edx
 0000068B  81 FA 00000100	        cmp      edx, _SIZE_TABLE                         ; 256
 00000691  72 B8		        jb       aesSetKey_6
				;       --------------------

				;;ha;;  ; kt_init = 1;
				;;ha;;          mov      DWORD PTR kt_init, 1                     ; Set kt_init done

 00000693			aesSetKey_7:
				        ; SK = ctx->drk;
 00000693  8B 55 08		        mov      edx, DWORD PTR _ctx
 00000696  81 C2 00000100	        add      edx, _ctxStruct.drk                      ; Decryption round keys 
 0000069C  89 55 FC		        mov      DWORD PTR _SK, edx                       ; edx = SK
				                                                          ; ecx = RK
				        ; *SK++ = *RK++;
 0000069F  8B 01		        mov      eax, DWORD PTR [ecx+0*SIZEOF DWORD]      ; RK[0]
 000006A1  89 02		        mov      DWORD PTR [edx+0*SIZEOF DWORD], eax      ; SK[0]
				        ; *SK++ = *RK++;
 000006A3  8B 41 04		        mov      eax, DWORD PTR [ecx+1*SIZEOF DWORD]      ; RK[1]
 000006A6  89 42 04		        mov      DWORD PTR [edx+1*SIZEOF DWORD], eax      ; SK[1]
				        ; *SK++ = *RK++;
 000006A9  8B 41 08		        mov      eax, DWORD PTR [ecx+2*SIZEOF DWORD]      ; RK[2]
 000006AC  89 42 08		        mov      DWORD PTR [edx+2*SIZEOF DWORD], eax      ; SK[2]
				        ; *SK++ = *RK++;
 000006AF  8B 41 0C		        mov      eax, DWORD PTR [ecx+3*SIZEOF DWORD]      ; RK[3]
 000006B2  89 42 0C		        mov      DWORD PTR [edx+3*SIZEOF DWORD], eax      ; SK[3]

				        ; for( i = 1; i < ctx->nr; i++ )
 000006B5  C7 45 F4		        mov      DWORD PTR __i, 1
	   00000001

 000006BC			aesSetKey_8:
 000006BC  83 E9 10		        sub      ecx, 4*SIZEOF DWORD                      ; RK -= 4;
 000006BF  83 C2 10		        add      edx, 4*SIZEOF DWORD                      ; SK += 4;

				        SET_KEY 0,1,2,3
 000006C2  8B 01	     2	        mov      eax, DWORD PTR [ecx+0*SIZEOF DWORD]     ; eax = RK[0]
 000006C4  C1 E8 18	     2	        shr      eax, 24
 000006C7  0F B6 C0	     2	        movzx    eax, al
 000006CA  8B 04 85	     2	        mov      eax, DWORD PTR _KT0[eax*SIZEOF DWORD]
	   00000E0C R
 000006D1  8B 19	     2	        mov      ebx, DWORD PTR [ecx+0*SIZEOF DWORD]     ; ebx = RK[0]
 000006D3  C1 EB 10	     2	        shr      ebx, 16
 000006D6  0F B6 DB	     2	        movzx    ebx, bl
 000006D9  33 04 9D	     2	        xor      eax, DWORD PTR _KT1[ebx*SIZEOF DWORD]
	   00000A0C R
 000006E0  8B 19	     2	        mov      ebx, DWORD PTR [ecx+0*SIZEOF DWORD]     ; ebx = RK[0]
 000006E2  C1 EB 08	     2	        shr      ebx, 8
 000006E5  0F B6 DB	     2	        movzx    ebx, bl
 000006E8  33 04 9D	     2	        xor      eax, DWORD PTR _KT2[ebx*SIZEOF DWORD]
	   0000060C R
 000006EF  0F B6 19	     2	        movzx    ebx, BYTE PTR [ecx+0*SIZEOF DWORD]      ; ebx = RK[0]
 000006F2  33 04 9D	     2	        xor      eax, DWORD PTR _KT3[ebx*SIZEOF DWORD]
	   0000020C R
 000006F9  89 02	     2	        mov      DWORD PTR [edx+0*SIZEOF DWORD], eax     ; SK[0] = eax
 000006FB  8B 41 04	     2	        mov      eax, DWORD PTR [ecx+1*SIZEOF DWORD]     ; eax = RK[0]
 000006FE  C1 E8 18	     2	        shr      eax, 24
 00000701  0F B6 C0	     2	        movzx    eax, al
 00000704  8B 04 85	     2	        mov      eax, DWORD PTR _KT0[eax*SIZEOF DWORD]
	   00000E0C R
 0000070B  8B 59 04	     2	        mov      ebx, DWORD PTR [ecx+1*SIZEOF DWORD]     ; ebx = RK[0]
 0000070E  C1 EB 10	     2	        shr      ebx, 16
 00000711  0F B6 DB	     2	        movzx    ebx, bl
 00000714  33 04 9D	     2	        xor      eax, DWORD PTR _KT1[ebx*SIZEOF DWORD]
	   00000A0C R
 0000071B  8B 59 04	     2	        mov      ebx, DWORD PTR [ecx+1*SIZEOF DWORD]     ; ebx = RK[0]
 0000071E  C1 EB 08	     2	        shr      ebx, 8
 00000721  0F B6 DB	     2	        movzx    ebx, bl
 00000724  33 04 9D	     2	        xor      eax, DWORD PTR _KT2[ebx*SIZEOF DWORD]
	   0000060C R
 0000072B  0F B6 59 04	     2	        movzx    ebx, BYTE PTR [ecx+1*SIZEOF DWORD]      ; ebx = RK[0]
 0000072F  33 04 9D	     2	        xor      eax, DWORD PTR _KT3[ebx*SIZEOF DWORD]
	   0000020C R
 00000736  89 42 04	     2	        mov      DWORD PTR [edx+1*SIZEOF DWORD], eax     ; SK[0] = eax
 00000739  8B 41 08	     2	        mov      eax, DWORD PTR [ecx+2*SIZEOF DWORD]     ; eax = RK[0]
 0000073C  C1 E8 18	     2	        shr      eax, 24
 0000073F  0F B6 C0	     2	        movzx    eax, al
 00000742  8B 04 85	     2	        mov      eax, DWORD PTR _KT0[eax*SIZEOF DWORD]
	   00000E0C R
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 22 - 1


 00000749  8B 59 08	     2	        mov      ebx, DWORD PTR [ecx+2*SIZEOF DWORD]     ; ebx = RK[0]
 0000074C  C1 EB 10	     2	        shr      ebx, 16
 0000074F  0F B6 DB	     2	        movzx    ebx, bl
 00000752  33 04 9D	     2	        xor      eax, DWORD PTR _KT1[ebx*SIZEOF DWORD]
	   00000A0C R
 00000759  8B 59 08	     2	        mov      ebx, DWORD PTR [ecx+2*SIZEOF DWORD]     ; ebx = RK[0]
 0000075C  C1 EB 08	     2	        shr      ebx, 8
 0000075F  0F B6 DB	     2	        movzx    ebx, bl
 00000762  33 04 9D	     2	        xor      eax, DWORD PTR _KT2[ebx*SIZEOF DWORD]
	   0000060C R
 00000769  0F B6 59 08	     2	        movzx    ebx, BYTE PTR [ecx+2*SIZEOF DWORD]      ; ebx = RK[0]
 0000076D  33 04 9D	     2	        xor      eax, DWORD PTR _KT3[ebx*SIZEOF DWORD]
	   0000020C R
 00000774  89 42 08	     2	        mov      DWORD PTR [edx+2*SIZEOF DWORD], eax     ; SK[0] = eax
 00000777  8B 41 0C	     2	        mov      eax, DWORD PTR [ecx+3*SIZEOF DWORD]     ; eax = RK[0]
 0000077A  C1 E8 18	     2	        shr      eax, 24
 0000077D  0F B6 C0	     2	        movzx    eax, al
 00000780  8B 04 85	     2	        mov      eax, DWORD PTR _KT0[eax*SIZEOF DWORD]
	   00000E0C R
 00000787  8B 59 0C	     2	        mov      ebx, DWORD PTR [ecx+3*SIZEOF DWORD]     ; ebx = RK[0]
 0000078A  C1 EB 10	     2	        shr      ebx, 16
 0000078D  0F B6 DB	     2	        movzx    ebx, bl
 00000790  33 04 9D	     2	        xor      eax, DWORD PTR _KT1[ebx*SIZEOF DWORD]
	   00000A0C R
 00000797  8B 59 0C	     2	        mov      ebx, DWORD PTR [ecx+3*SIZEOF DWORD]     ; ebx = RK[0]
 0000079A  C1 EB 08	     2	        shr      ebx, 8
 0000079D  0F B6 DB	     2	        movzx    ebx, bl
 000007A0  33 04 9D	     2	        xor      eax, DWORD PTR _KT2[ebx*SIZEOF DWORD]
	   0000060C R
 000007A7  0F B6 59 0C	     2	        movzx    ebx, BYTE PTR [ecx+3*SIZEOF DWORD]      ; ebx = RK[0]
 000007AB  33 04 9D	     2	        xor      eax, DWORD PTR _KT3[ebx*SIZEOF DWORD]
	   0000020C R
 000007B2  89 42 0C	     2	        mov      DWORD PTR [edx+3*SIZEOF DWORD], eax     ; SK[0] = eax

 000007B5  FF 45 F4		        inc      DWORD PTR __i                            ; i++
 000007B8  8B 45 F4		        mov      eax, DWORD PTR __i
 000007BB  8B 5D 08		        mov      ebx, DWORD PTR _ctx
 000007BE  3B 83 00000200	        cmp      eax, DWORD PTR [ebx]._ctxStruct.rkEnd    ; +512
 000007C4  0F 82 FFFFFEF2	        jb       aesSetKey_8
				;       --------------------
				        
 000007CA			aesSetKey_exit:
 000007CA  83 E9 10		        sub      ecx, 4*SIZEOF DWORD                      ; RK -= 4;            
 000007CD  83 C2 10		        add      edx, 4*SIZEOF DWORD                      ; SK += 4; (edx = ctx.drk)
				                                                          
				        ; *SK++ = *RK++;
 000007D0  8B 01		        mov      eax, DWORD PTR [ecx+0*SIZEOF DWORD]      ; eax = RK[0]
 000007D2  89 02		        mov      DWORD PTR [edx+0*SIZEOF DWORD], eax      ; SK[0] = eax
				        ; *SK++ = *RK++;
 000007D4  8B 41 04		        mov      eax, DWORD PTR [ecx+1*SIZEOF DWORD]      ; eax = RK[1]
 000007D7  89 42 04		        mov      DWORD PTR [edx+1*SIZEOF DWORD], eax      ; SK[1] = eax
				        ; *SK++ = *RK++;
 000007DA  8B 41 08		        mov      eax, DWORD PTR [ecx+2*SIZEOF DWORD]      ; eax = RK[2]
 000007DD  89 42 08		        mov      DWORD PTR [edx+2*SIZEOF DWORD], eax      ; SK[2] = eax
				        ; *SK++ = *RK++;
 000007E0  8B 41 0C		        mov      eax, DWORD PTR [ecx+3*SIZEOF DWORD]      ; eax = RK[3]
 000007E3  89 42 0C		        mov      DWORD PTR [edx+3*SIZEOF DWORD], eax      ; SK[3] = eax

 000007E6			aesSetKey_ret:
				        ret
 000007E6  5F		   *	    pop    edi
 000007E7  5E		   *	    pop    esi
 000007E8  5B		   *	    pop    ebx
 000007E9  C9		   *	    leave  
 000007EA  C3		   *	    ret    00000h
 000007EB			aesSetKey ENDP ; aesSetKey


				;------------------------------------------------------------------------------
				; 
				;                       _aesAlgorithm
				;
				; void aes_encrypt(aes_context *ctx, unsigned char input[16],
				;                                    unsigned char output[16])
				;
				;       Function compile flags: /Odtp
				;
				;       ----------- C++ Compiler optimization turned off  -----------
				;            Therefore extensive [esp] indexing is inevitable.
				;              May cause headaches sometimes, when rewriting
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 23 - 1


				;               for INVOKE interface mechanism using [ebp].
				;
 000007EB			_aesAlgorithm PROC C USES ebx esi edi, _ctx, _input, _output
				        LOCAL   _X0:DWORD       ; uint32 *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;
				        LOCAL   _X1:DWORD
				        LOCAL   _X2:DWORD
				        LOCAL   _X3:DWORD
				        LOCAL   _Y0:DWORD
				        LOCAL   _Y1:DWORD
				        LOCAL   _Y2:DWORD
				        LOCAL   _Y3:DWORD                                        
				        LOCAL   _RK:DWORD

 000007EB  55		   *	    push   ebp
 000007EC  8B EC	   *	    mov    ebp, esp
 000007EE  83 C4 DC	   *	    add    esp, 0FFFFFFDCh
 000007F1  53		   *	    push   ebx
 000007F2  56		   *	    push   esi
 000007F3  57		   *	    push   edi
 000007F4  8B 45 08		        mov      eax, DWORD PTR _ctx    ; eax = ctx->_ctxStruct;
 000007F7  03 05 00000004 R	        add      eax, DWORD PTR aesMode ; _ctxStruct.erk / _ctxStruct.drk
 000007FD  89 45 DC		        mov      DWORD PTR _RK, eax     ; Init _RK

				        ; GET_UINT32_BE( X0, input,  0 ); X0 ^= RK[0];   ; Get plain data
				        _GET_UINT32 _X0, _input, 0
 00000800  8B 4D 0C	     1	        mov      ecx, DWORD PTR _input
 00000803  8B 01	     1	        mov      eax, DWORD PTR [ecx+0*SIZEOF DWORD]
 00000805  0F C8	     1	        bswap    eax                                    ; Reverse the byte order
 00000807  8B 4D DC	     1	        mov      ecx, DWORD PTR _RK                     ; X0 ^= RK[i];
 0000080A  33 01	     1	        xor      eax, DWORD PTR [ecx+0*SIZEOF DWORD]    
 0000080C  89 45 FC	     1	        mov      DWORD PTR _X0, eax                      ; Bits[31:0]
				        ; GET_UINT32_BE( X1, input,  4 ); X1 ^= RK[1];
				        _GET_UINT32 _X1, _input, 1
 0000080F  8B 4D 0C	     1	        mov      ecx, DWORD PTR _input
 00000812  8B 41 04	     1	        mov      eax, DWORD PTR [ecx+1*SIZEOF DWORD]
 00000815  0F C8	     1	        bswap    eax                                    ; Reverse the byte order
 00000817  8B 4D DC	     1	        mov      ecx, DWORD PTR _RK                     ; X0 ^= RK[i];
 0000081A  33 41 04	     1	        xor      eax, DWORD PTR [ecx+1*SIZEOF DWORD]    
 0000081D  89 45 F8	     1	        mov      DWORD PTR _X1, eax                      ; Bits[31:0]
				        ; GET_UINT32_BE( X2, input,  8 ); X2 ^= RK[2];
				        _GET_UINT32 _X2, _input, 2
 00000820  8B 4D 0C	     1	        mov      ecx, DWORD PTR _input
 00000823  8B 41 08	     1	        mov      eax, DWORD PTR [ecx+2*SIZEOF DWORD]
 00000826  0F C8	     1	        bswap    eax                                    ; Reverse the byte order
 00000828  8B 4D DC	     1	        mov      ecx, DWORD PTR _RK                     ; X0 ^= RK[i];
 0000082B  33 41 08	     1	        xor      eax, DWORD PTR [ecx+2*SIZEOF DWORD]    
 0000082E  89 45 F4	     1	        mov      DWORD PTR _X2, eax                      ; Bits[31:0]
				        ; GET_UINT32_BE( X3, input, 12 ); X3 ^= RK[3];
				        _GET_UINT32 _X3, _input, 3
 00000831  8B 4D 0C	     1	        mov      ecx, DWORD PTR _input
 00000834  8B 41 0C	     1	        mov      eax, DWORD PTR [ecx+3*SIZEOF DWORD]
 00000837  0F C8	     1	        bswap    eax                                    ; Reverse the byte order
 00000839  8B 4D DC	     1	        mov      ecx, DWORD PTR _RK                     ; X0 ^= RK[i];
 0000083C  33 41 0C	     1	        xor      eax, DWORD PTR [ecx+3*SIZEOF DWORD]    
 0000083F  89 45 F0	     1	        mov      DWORD PTR _X3, eax                      ; Bits[31:0]

				        ;  #define AES_FROUND(X0,X1,X2,X3,Y0,Y1,Y2,Y3)          \
				        ;  {                                                    \
				        ;      RK += 4;                                         \
				        ;                                                       \
				        ;      X0 = RK[0] ^ FT0[ (uint8) ( Y0 >> 24 ) ] ^       \
				        ;                   FT1[ (uint8) ( Y1 >> 16 ) ] ^       \
				        ;                   FT2[ (uint8) ( Y2 >>  8 ) ] ^       \
				        ;                   FT3[ (uint8) ( Y3       ) ];        \
				        ;                                                       \
				        ;      X1 = RK[1] ^ FT0[ (uint8) ( Y1 >> 24 ) ] ^       \
				        ;                   FT1[ (uint8) ( Y2 >> 16 ) ] ^       \
				        ;                   FT2[ (uint8) ( Y3 >>  8 ) ] ^       \
				        ;                   FT3[ (uint8) ( Y0       ) ];        \
				        ;                                                       \
				        ;      X2 = RK[2] ^ FT0[ (uint8) ( Y2 >> 24 ) ] ^       \
				        ;                   FT1[ (uint8) ( Y3 >> 16 ) ] ^       \
				        ;                   FT2[ (uint8) ( Y0 >>  8 ) ] ^       \
				        ;                   FT3[ (uint8) ( Y1       ) ];        \
				        ;                                                       \
				        ;      X3 = RK[3] ^ FT0[ (uint8) ( Y3 >> 24 ) ] ^       \
				        ;                   FT1[ (uint8) ( Y0 >> 16 ) ] ^       \
				        ;                   FT2[ (uint8) ( Y1 >>  8 ) ] ^       \
				        ;                   FT3[ (uint8) ( Y2       ) ];        \
				        ;  }
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 24 - 1



				        ; 01 AES_FROUND(Y0,Y1,Y2,Y3, X0,X1,X2,X3);
				        AES_ROUND _Y, _X, 0,1,2,3       
 00000842  83 45 DC 10	     1	        add      DWORD PTR _RK, 4*SIZEOF DWORD          ; RK += 4; ; ecx = RK           
 00000846  8B 4D DC	     1	        mov      ecx, DWORD PTR _RK                                  
 00000849  81 3D 00000004 R  1	        cmp      DWORD PTR aesMode, _ctxStruct.drk      ; Check: ENCRYPT / DECIPHER
	   00000100
 00000853  0F 84 00000108    1	        je       ??0000                                       
 00000859  8B 01	     2	        mov      eax, DWORD PTR [ecx+0*SIZEOF DWORD]              ; ecx = RK[0]
 0000085B  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b0
 0000085E  C1 EA 18	     2	        shr      edx, 24                        
 00000861  0F B6 D2	     2	        movzx    edx, dl
 00000864  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 0000086B  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b1    / b3
 0000086E  C1 EA 10	     2	        shr      edx, 16                        
 00000871  0F B6 D2	     2	        movzx    edx, dl
 00000874  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 0000087B  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b2
 0000087E  C1 EA 08	     2	        shr      edx, 8
 00000881  0F B6 D2	     2	        movzx    edx, dl
 00000884  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 0000088B  0F B6 55 F0	     2	        movzx    edx, BYTE PTR @CatStr(_X,3)                      ; b3    / b1
 0000088F  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 00000896  89 45 EC	     2	        mov      DWORD PTR @CatStr(_Y,0), eax                     ; a0
 00000899  8B 41 04	     2	        mov      eax, DWORD PTR [ecx+1*SIZEOF DWORD]              ; ecx = RK[0]
 0000089C  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b0
 0000089F  C1 EA 18	     2	        shr      edx, 24                        
 000008A2  0F B6 D2	     2	        movzx    edx, dl
 000008A5  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 000008AC  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b1    / b3
 000008AF  C1 EA 10	     2	        shr      edx, 16                        
 000008B2  0F B6 D2	     2	        movzx    edx, dl
 000008B5  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 000008BC  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b2
 000008BF  C1 EA 08	     2	        shr      edx, 8
 000008C2  0F B6 D2	     2	        movzx    edx, dl
 000008C5  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 000008CC  0F B6 55 FC	     2	        movzx    edx, BYTE PTR @CatStr(_X,0)                      ; b3    / b1
 000008D0  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 000008D7  89 45 E8	     2	        mov      DWORD PTR @CatStr(_Y,1), eax                     ; a0
 000008DA  8B 41 08	     2	        mov      eax, DWORD PTR [ecx+2*SIZEOF DWORD]              ; ecx = RK[0]
 000008DD  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b0
 000008E0  C1 EA 18	     2	        shr      edx, 24                        
 000008E3  0F B6 D2	     2	        movzx    edx, dl
 000008E6  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 000008ED  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b1    / b3
 000008F0  C1 EA 10	     2	        shr      edx, 16                        
 000008F3  0F B6 D2	     2	        movzx    edx, dl
 000008F6  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 000008FD  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b2
 00000900  C1 EA 08	     2	        shr      edx, 8
 00000903  0F B6 D2	     2	        movzx    edx, dl
 00000906  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 0000090D  0F B6 55 F8	     2	        movzx    edx, BYTE PTR @CatStr(_X,1)                      ; b3    / b1
 00000911  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 00000918  89 45 E4	     2	        mov      DWORD PTR @CatStr(_Y,2), eax                     ; a0
 0000091B  8B 41 0C	     2	        mov      eax, DWORD PTR [ecx+3*SIZEOF DWORD]              ; ecx = RK[0]
 0000091E  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b0
 00000921  C1 EA 18	     2	        shr      edx, 24                        
 00000924  0F B6 D2	     2	        movzx    edx, dl
 00000927  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 0000092E  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b1    / b3
 00000931  C1 EA 10	     2	        shr      edx, 16                        
 00000934  0F B6 D2	     2	        movzx    edx, dl
 00000937  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 0000093E  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b2
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 25 - 1


 00000941  C1 EA 08	     2	        shr      edx, 8
 00000944  0F B6 D2	     2	        movzx    edx, dl
 00000947  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 0000094E  0F B6 55 F4	     2	        movzx    edx, BYTE PTR @CatStr(_X,2)                      ; b3    / b1
 00000952  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 00000959  89 45 E0	     2	        mov      DWORD PTR @CatStr(_Y,3), eax                     ; a0
 0000095C  E9 00000103	     1	        jmp      ??0001
 00000961		     1	??0000:                                                       ; Decipher  
 00000961  8B 01	     2	        mov      eax, DWORD PTR [ecx+0*SIZEOF DWORD]              ; ecx = RK[0]
 00000963  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b0
 00000966  C1 EA 18	     2	        shr      edx, 24                        
 00000969  0F B6 D2	     2	        movzx    edx, dl
 0000096C  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 00000973  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b1    / b3
 00000976  C1 EA 10	     2	        shr      edx, 16                        
 00000979  0F B6 D2	     2	        movzx    edx, dl
 0000097C  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 00000983  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b2
 00000986  C1 EA 08	     2	        shr      edx, 8
 00000989  0F B6 D2	     2	        movzx    edx, dl
 0000098C  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 00000993  0F B6 55 F8	     2	        movzx    edx, BYTE PTR @CatStr(_X,1)                      ; b3    / b1
 00000997  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 0000099E  89 45 EC	     2	        mov      DWORD PTR @CatStr(_Y,0), eax                     ; a0
 000009A1  8B 41 0C	     2	        mov      eax, DWORD PTR [ecx+3*SIZEOF DWORD]              ; ecx = RK[0]
 000009A4  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b0
 000009A7  C1 EA 18	     2	        shr      edx, 24                        
 000009AA  0F B6 D2	     2	        movzx    edx, dl
 000009AD  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 000009B4  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b1    / b3
 000009B7  C1 EA 10	     2	        shr      edx, 16                        
 000009BA  0F B6 D2	     2	        movzx    edx, dl
 000009BD  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 000009C4  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b2
 000009C7  C1 EA 08	     2	        shr      edx, 8
 000009CA  0F B6 D2	     2	        movzx    edx, dl
 000009CD  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 000009D4  0F B6 55 FC	     2	        movzx    edx, BYTE PTR @CatStr(_X,0)                      ; b3    / b1
 000009D8  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 000009DF  89 45 E0	     2	        mov      DWORD PTR @CatStr(_Y,3), eax                     ; a0
 000009E2  8B 41 08	     2	        mov      eax, DWORD PTR [ecx+2*SIZEOF DWORD]              ; ecx = RK[0]
 000009E5  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b0
 000009E8  C1 EA 18	     2	        shr      edx, 24                        
 000009EB  0F B6 D2	     2	        movzx    edx, dl
 000009EE  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 000009F5  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b1    / b3
 000009F8  C1 EA 10	     2	        shr      edx, 16                        
 000009FB  0F B6 D2	     2	        movzx    edx, dl
 000009FE  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 00000A05  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b2
 00000A08  C1 EA 08	     2	        shr      edx, 8
 00000A0B  0F B6 D2	     2	        movzx    edx, dl
 00000A0E  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 00000A15  0F B6 55 F0	     2	        movzx    edx, BYTE PTR @CatStr(_X,3)                      ; b3    / b1
 00000A19  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 00000A20  89 45 E4	     2	        mov      DWORD PTR @CatStr(_Y,2), eax                     ; a0
 00000A23  8B 41 04	     2	        mov      eax, DWORD PTR [ecx+1*SIZEOF DWORD]              ; ecx = RK[0]
 00000A26  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b0
 00000A29  C1 EA 18	     2	        shr      edx, 24                        
 00000A2C  0F B6 D2	     2	        movzx    edx, dl
 00000A2F  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 00000A36  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b1    / b3
 00000A39  C1 EA 10	     2	        shr      edx, 16                        
 00000A3C  0F B6 D2	     2	        movzx    edx, dl
 00000A3F  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 26 - 1


	   0000260C R
 00000A46  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b2
 00000A49  C1 EA 08	     2	        shr      edx, 8
 00000A4C  0F B6 D2	     2	        movzx    edx, dl
 00000A4F  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 00000A56  0F B6 55 F4	     2	        movzx    edx, BYTE PTR @CatStr(_X,2)                      ; b3    / b1
 00000A5A  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 00000A61  89 45 E8	     2	        mov      DWORD PTR @CatStr(_Y,1), eax                     ; a0
 00000A64		     1	??0001:
				        
				        ; 02 AES_FROUND(X0,X1,X2,X3, Y0,Y1,Y2,Y3);
				        AES_ROUND _X, _Y, 0,1,2,3       
 00000A64  83 45 DC 10	     1	        add      DWORD PTR _RK, 4*SIZEOF DWORD          ; RK += 4; ; ecx = RK           
 00000A68  8B 4D DC	     1	        mov      ecx, DWORD PTR _RK                                  
 00000A6B  81 3D 00000004 R  1	        cmp      DWORD PTR aesMode, _ctxStruct.drk      ; Check: ENCRYPT / DECIPHER
	   00000100
 00000A75  0F 84 00000108    1	        je       ??0002                                       
 00000A7B  8B 01	     2	        mov      eax, DWORD PTR [ecx+0*SIZEOF DWORD]              ; ecx = RK[0]
 00000A7D  8B 55 EC	     2	        mov      edx, DWORD PTR @CatStr(_Y,0)                     ; b0
 00000A80  C1 EA 18	     2	        shr      edx, 24                        
 00000A83  0F B6 D2	     2	        movzx    edx, dl
 00000A86  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 00000A8D  8B 55 E8	     2	        mov      edx, DWORD PTR @CatStr(_Y,1)                     ; b1    / b3
 00000A90  C1 EA 10	     2	        shr      edx, 16                        
 00000A93  0F B6 D2	     2	        movzx    edx, dl
 00000A96  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 00000A9D  8B 55 E4	     2	        mov      edx, DWORD PTR @CatStr(_Y,2)                     ; b2
 00000AA0  C1 EA 08	     2	        shr      edx, 8
 00000AA3  0F B6 D2	     2	        movzx    edx, dl
 00000AA6  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 00000AAD  0F B6 55 E0	     2	        movzx    edx, BYTE PTR @CatStr(_Y,3)                      ; b3    / b1
 00000AB1  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 00000AB8  89 45 FC	     2	        mov      DWORD PTR @CatStr(_X,0), eax                     ; a0
 00000ABB  8B 41 04	     2	        mov      eax, DWORD PTR [ecx+1*SIZEOF DWORD]              ; ecx = RK[0]
 00000ABE  8B 55 E8	     2	        mov      edx, DWORD PTR @CatStr(_Y,1)                     ; b0
 00000AC1  C1 EA 18	     2	        shr      edx, 24                        
 00000AC4  0F B6 D2	     2	        movzx    edx, dl
 00000AC7  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 00000ACE  8B 55 E4	     2	        mov      edx, DWORD PTR @CatStr(_Y,2)                     ; b1    / b3
 00000AD1  C1 EA 10	     2	        shr      edx, 16                        
 00000AD4  0F B6 D2	     2	        movzx    edx, dl
 00000AD7  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 00000ADE  8B 55 E0	     2	        mov      edx, DWORD PTR @CatStr(_Y,3)                     ; b2
 00000AE1  C1 EA 08	     2	        shr      edx, 8
 00000AE4  0F B6 D2	     2	        movzx    edx, dl
 00000AE7  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 00000AEE  0F B6 55 EC	     2	        movzx    edx, BYTE PTR @CatStr(_Y,0)                      ; b3    / b1
 00000AF2  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 00000AF9  89 45 F8	     2	        mov      DWORD PTR @CatStr(_X,1), eax                     ; a0
 00000AFC  8B 41 08	     2	        mov      eax, DWORD PTR [ecx+2*SIZEOF DWORD]              ; ecx = RK[0]
 00000AFF  8B 55 E4	     2	        mov      edx, DWORD PTR @CatStr(_Y,2)                     ; b0
 00000B02  C1 EA 18	     2	        shr      edx, 24                        
 00000B05  0F B6 D2	     2	        movzx    edx, dl
 00000B08  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 00000B0F  8B 55 E0	     2	        mov      edx, DWORD PTR @CatStr(_Y,3)                     ; b1    / b3
 00000B12  C1 EA 10	     2	        shr      edx, 16                        
 00000B15  0F B6 D2	     2	        movzx    edx, dl
 00000B18  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 00000B1F  8B 55 EC	     2	        mov      edx, DWORD PTR @CatStr(_Y,0)                     ; b2
 00000B22  C1 EA 08	     2	        shr      edx, 8
 00000B25  0F B6 D2	     2	        movzx    edx, dl
 00000B28  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 00000B2F  0F B6 55 E8	     2	        movzx    edx, BYTE PTR @CatStr(_Y,1)                      ; b3    / b1
 00000B33  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 00000B3A  89 45 F4	     2	        mov      DWORD PTR @CatStr(_X,2), eax                     ; a0
 00000B3D  8B 41 0C	     2	        mov      eax, DWORD PTR [ecx+3*SIZEOF DWORD]              ; ecx = RK[0]
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 27 - 1


 00000B40  8B 55 E0	     2	        mov      edx, DWORD PTR @CatStr(_Y,3)                     ; b0
 00000B43  C1 EA 18	     2	        shr      edx, 24                        
 00000B46  0F B6 D2	     2	        movzx    edx, dl
 00000B49  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 00000B50  8B 55 EC	     2	        mov      edx, DWORD PTR @CatStr(_Y,0)                     ; b1    / b3
 00000B53  C1 EA 10	     2	        shr      edx, 16                        
 00000B56  0F B6 D2	     2	        movzx    edx, dl
 00000B59  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 00000B60  8B 55 E8	     2	        mov      edx, DWORD PTR @CatStr(_Y,1)                     ; b2
 00000B63  C1 EA 08	     2	        shr      edx, 8
 00000B66  0F B6 D2	     2	        movzx    edx, dl
 00000B69  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 00000B70  0F B6 55 E4	     2	        movzx    edx, BYTE PTR @CatStr(_Y,2)                      ; b3    / b1
 00000B74  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 00000B7B  89 45 F0	     2	        mov      DWORD PTR @CatStr(_X,3), eax                     ; a0
 00000B7E  E9 00000103	     1	        jmp      ??0003
 00000B83		     1	??0002:                                                       ; Decipher  
 00000B83  8B 01	     2	        mov      eax, DWORD PTR [ecx+0*SIZEOF DWORD]              ; ecx = RK[0]
 00000B85  8B 55 EC	     2	        mov      edx, DWORD PTR @CatStr(_Y,0)                     ; b0
 00000B88  C1 EA 18	     2	        shr      edx, 24                        
 00000B8B  0F B6 D2	     2	        movzx    edx, dl
 00000B8E  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 00000B95  8B 55 E0	     2	        mov      edx, DWORD PTR @CatStr(_Y,3)                     ; b1    / b3
 00000B98  C1 EA 10	     2	        shr      edx, 16                        
 00000B9B  0F B6 D2	     2	        movzx    edx, dl
 00000B9E  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 00000BA5  8B 55 E4	     2	        mov      edx, DWORD PTR @CatStr(_Y,2)                     ; b2
 00000BA8  C1 EA 08	     2	        shr      edx, 8
 00000BAB  0F B6 D2	     2	        movzx    edx, dl
 00000BAE  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 00000BB5  0F B6 55 E8	     2	        movzx    edx, BYTE PTR @CatStr(_Y,1)                      ; b3    / b1
 00000BB9  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 00000BC0  89 45 FC	     2	        mov      DWORD PTR @CatStr(_X,0), eax                     ; a0
 00000BC3  8B 41 0C	     2	        mov      eax, DWORD PTR [ecx+3*SIZEOF DWORD]              ; ecx = RK[0]
 00000BC6  8B 55 E0	     2	        mov      edx, DWORD PTR @CatStr(_Y,3)                     ; b0
 00000BC9  C1 EA 18	     2	        shr      edx, 24                        
 00000BCC  0F B6 D2	     2	        movzx    edx, dl
 00000BCF  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 00000BD6  8B 55 E4	     2	        mov      edx, DWORD PTR @CatStr(_Y,2)                     ; b1    / b3
 00000BD9  C1 EA 10	     2	        shr      edx, 16                        
 00000BDC  0F B6 D2	     2	        movzx    edx, dl
 00000BDF  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 00000BE6  8B 55 E8	     2	        mov      edx, DWORD PTR @CatStr(_Y,1)                     ; b2
 00000BE9  C1 EA 08	     2	        shr      edx, 8
 00000BEC  0F B6 D2	     2	        movzx    edx, dl
 00000BEF  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 00000BF6  0F B6 55 EC	     2	        movzx    edx, BYTE PTR @CatStr(_Y,0)                      ; b3    / b1
 00000BFA  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 00000C01  89 45 F0	     2	        mov      DWORD PTR @CatStr(_X,3), eax                     ; a0
 00000C04  8B 41 08	     2	        mov      eax, DWORD PTR [ecx+2*SIZEOF DWORD]              ; ecx = RK[0]
 00000C07  8B 55 E4	     2	        mov      edx, DWORD PTR @CatStr(_Y,2)                     ; b0
 00000C0A  C1 EA 18	     2	        shr      edx, 24                        
 00000C0D  0F B6 D2	     2	        movzx    edx, dl
 00000C10  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 00000C17  8B 55 E8	     2	        mov      edx, DWORD PTR @CatStr(_Y,1)                     ; b1    / b3
 00000C1A  C1 EA 10	     2	        shr      edx, 16                        
 00000C1D  0F B6 D2	     2	        movzx    edx, dl
 00000C20  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 00000C27  8B 55 EC	     2	        mov      edx, DWORD PTR @CatStr(_Y,0)                     ; b2
 00000C2A  C1 EA 08	     2	        shr      edx, 8
 00000C2D  0F B6 D2	     2	        movzx    edx, dl
 00000C30  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 00000C37  0F B6 55 E0	     2	        movzx    edx, BYTE PTR @CatStr(_Y,3)                      ; b3    / b1
 00000C3B  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 28 - 1


 00000C42  89 45 F4	     2	        mov      DWORD PTR @CatStr(_X,2), eax                     ; a0
 00000C45  8B 41 04	     2	        mov      eax, DWORD PTR [ecx+1*SIZEOF DWORD]              ; ecx = RK[0]
 00000C48  8B 55 E8	     2	        mov      edx, DWORD PTR @CatStr(_Y,1)                     ; b0
 00000C4B  C1 EA 18	     2	        shr      edx, 24                        
 00000C4E  0F B6 D2	     2	        movzx    edx, dl
 00000C51  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 00000C58  8B 55 EC	     2	        mov      edx, DWORD PTR @CatStr(_Y,0)                     ; b1    / b3
 00000C5B  C1 EA 10	     2	        shr      edx, 16                        
 00000C5E  0F B6 D2	     2	        movzx    edx, dl
 00000C61  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 00000C68  8B 55 E0	     2	        mov      edx, DWORD PTR @CatStr(_Y,3)                     ; b2
 00000C6B  C1 EA 08	     2	        shr      edx, 8
 00000C6E  0F B6 D2	     2	        movzx    edx, dl
 00000C71  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 00000C78  0F B6 55 E4	     2	        movzx    edx, BYTE PTR @CatStr(_Y,2)                      ; b3    / b1
 00000C7C  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 00000C83  89 45 F8	     2	        mov      DWORD PTR @CatStr(_X,1), eax                     ; a0
 00000C86		     1	??0003:
				        
				        ; 03 AES_FROUND(Y0,Y1,Y2,Y3, X0,X1,X2,X3);
				        AES_ROUND _Y, _X, 0,1,2,3       
 00000C86  83 45 DC 10	     1	        add      DWORD PTR _RK, 4*SIZEOF DWORD          ; RK += 4; ; ecx = RK           
 00000C8A  8B 4D DC	     1	        mov      ecx, DWORD PTR _RK                                  
 00000C8D  81 3D 00000004 R  1	        cmp      DWORD PTR aesMode, _ctxStruct.drk      ; Check: ENCRYPT / DECIPHER
	   00000100
 00000C97  0F 84 00000108    1	        je       ??0004                                       
 00000C9D  8B 01	     2	        mov      eax, DWORD PTR [ecx+0*SIZEOF DWORD]              ; ecx = RK[0]
 00000C9F  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b0
 00000CA2  C1 EA 18	     2	        shr      edx, 24                        
 00000CA5  0F B6 D2	     2	        movzx    edx, dl
 00000CA8  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 00000CAF  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b1    / b3
 00000CB2  C1 EA 10	     2	        shr      edx, 16                        
 00000CB5  0F B6 D2	     2	        movzx    edx, dl
 00000CB8  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 00000CBF  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b2
 00000CC2  C1 EA 08	     2	        shr      edx, 8
 00000CC5  0F B6 D2	     2	        movzx    edx, dl
 00000CC8  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 00000CCF  0F B6 55 F0	     2	        movzx    edx, BYTE PTR @CatStr(_X,3)                      ; b3    / b1
 00000CD3  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 00000CDA  89 45 EC	     2	        mov      DWORD PTR @CatStr(_Y,0), eax                     ; a0
 00000CDD  8B 41 04	     2	        mov      eax, DWORD PTR [ecx+1*SIZEOF DWORD]              ; ecx = RK[0]
 00000CE0  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b0
 00000CE3  C1 EA 18	     2	        shr      edx, 24                        
 00000CE6  0F B6 D2	     2	        movzx    edx, dl
 00000CE9  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 00000CF0  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b1    / b3
 00000CF3  C1 EA 10	     2	        shr      edx, 16                        
 00000CF6  0F B6 D2	     2	        movzx    edx, dl
 00000CF9  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 00000D00  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b2
 00000D03  C1 EA 08	     2	        shr      edx, 8
 00000D06  0F B6 D2	     2	        movzx    edx, dl
 00000D09  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 00000D10  0F B6 55 FC	     2	        movzx    edx, BYTE PTR @CatStr(_X,0)                      ; b3    / b1
 00000D14  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 00000D1B  89 45 E8	     2	        mov      DWORD PTR @CatStr(_Y,1), eax                     ; a0
 00000D1E  8B 41 08	     2	        mov      eax, DWORD PTR [ecx+2*SIZEOF DWORD]              ; ecx = RK[0]
 00000D21  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b0
 00000D24  C1 EA 18	     2	        shr      edx, 24                        
 00000D27  0F B6 D2	     2	        movzx    edx, dl
 00000D2A  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 00000D31  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b1    / b3
 00000D34  C1 EA 10	     2	        shr      edx, 16                        
 00000D37  0F B6 D2	     2	        movzx    edx, dl
 00000D3A  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 29 - 1


	   00001A0C R
 00000D41  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b2
 00000D44  C1 EA 08	     2	        shr      edx, 8
 00000D47  0F B6 D2	     2	        movzx    edx, dl
 00000D4A  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 00000D51  0F B6 55 F8	     2	        movzx    edx, BYTE PTR @CatStr(_X,1)                      ; b3    / b1
 00000D55  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 00000D5C  89 45 E4	     2	        mov      DWORD PTR @CatStr(_Y,2), eax                     ; a0
 00000D5F  8B 41 0C	     2	        mov      eax, DWORD PTR [ecx+3*SIZEOF DWORD]              ; ecx = RK[0]
 00000D62  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b0
 00000D65  C1 EA 18	     2	        shr      edx, 24                        
 00000D68  0F B6 D2	     2	        movzx    edx, dl
 00000D6B  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 00000D72  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b1    / b3
 00000D75  C1 EA 10	     2	        shr      edx, 16                        
 00000D78  0F B6 D2	     2	        movzx    edx, dl
 00000D7B  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 00000D82  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b2
 00000D85  C1 EA 08	     2	        shr      edx, 8
 00000D88  0F B6 D2	     2	        movzx    edx, dl
 00000D8B  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 00000D92  0F B6 55 F4	     2	        movzx    edx, BYTE PTR @CatStr(_X,2)                      ; b3    / b1
 00000D96  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 00000D9D  89 45 E0	     2	        mov      DWORD PTR @CatStr(_Y,3), eax                     ; a0
 00000DA0  E9 00000103	     1	        jmp      ??0005
 00000DA5		     1	??0004:                                                       ; Decipher  
 00000DA5  8B 01	     2	        mov      eax, DWORD PTR [ecx+0*SIZEOF DWORD]              ; ecx = RK[0]
 00000DA7  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b0
 00000DAA  C1 EA 18	     2	        shr      edx, 24                        
 00000DAD  0F B6 D2	     2	        movzx    edx, dl
 00000DB0  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 00000DB7  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b1    / b3
 00000DBA  C1 EA 10	     2	        shr      edx, 16                        
 00000DBD  0F B6 D2	     2	        movzx    edx, dl
 00000DC0  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 00000DC7  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b2
 00000DCA  C1 EA 08	     2	        shr      edx, 8
 00000DCD  0F B6 D2	     2	        movzx    edx, dl
 00000DD0  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 00000DD7  0F B6 55 F8	     2	        movzx    edx, BYTE PTR @CatStr(_X,1)                      ; b3    / b1
 00000DDB  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 00000DE2  89 45 EC	     2	        mov      DWORD PTR @CatStr(_Y,0), eax                     ; a0
 00000DE5  8B 41 0C	     2	        mov      eax, DWORD PTR [ecx+3*SIZEOF DWORD]              ; ecx = RK[0]
 00000DE8  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b0
 00000DEB  C1 EA 18	     2	        shr      edx, 24                        
 00000DEE  0F B6 D2	     2	        movzx    edx, dl
 00000DF1  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 00000DF8  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b1    / b3
 00000DFB  C1 EA 10	     2	        shr      edx, 16                        
 00000DFE  0F B6 D2	     2	        movzx    edx, dl
 00000E01  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 00000E08  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b2
 00000E0B  C1 EA 08	     2	        shr      edx, 8
 00000E0E  0F B6 D2	     2	        movzx    edx, dl
 00000E11  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 00000E18  0F B6 55 FC	     2	        movzx    edx, BYTE PTR @CatStr(_X,0)                      ; b3    / b1
 00000E1C  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 00000E23  89 45 E0	     2	        mov      DWORD PTR @CatStr(_Y,3), eax                     ; a0
 00000E26  8B 41 08	     2	        mov      eax, DWORD PTR [ecx+2*SIZEOF DWORD]              ; ecx = RK[0]
 00000E29  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b0
 00000E2C  C1 EA 18	     2	        shr      edx, 24                        
 00000E2F  0F B6 D2	     2	        movzx    edx, dl
 00000E32  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 00000E39  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b1    / b3
 00000E3C  C1 EA 10	     2	        shr      edx, 16                        
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 30 - 1


 00000E3F  0F B6 D2	     2	        movzx    edx, dl
 00000E42  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 00000E49  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b2
 00000E4C  C1 EA 08	     2	        shr      edx, 8
 00000E4F  0F B6 D2	     2	        movzx    edx, dl
 00000E52  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 00000E59  0F B6 55 F0	     2	        movzx    edx, BYTE PTR @CatStr(_X,3)                      ; b3    / b1
 00000E5D  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 00000E64  89 45 E4	     2	        mov      DWORD PTR @CatStr(_Y,2), eax                     ; a0
 00000E67  8B 41 04	     2	        mov      eax, DWORD PTR [ecx+1*SIZEOF DWORD]              ; ecx = RK[0]
 00000E6A  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b0
 00000E6D  C1 EA 18	     2	        shr      edx, 24                        
 00000E70  0F B6 D2	     2	        movzx    edx, dl
 00000E73  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 00000E7A  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b1    / b3
 00000E7D  C1 EA 10	     2	        shr      edx, 16                        
 00000E80  0F B6 D2	     2	        movzx    edx, dl
 00000E83  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 00000E8A  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b2
 00000E8D  C1 EA 08	     2	        shr      edx, 8
 00000E90  0F B6 D2	     2	        movzx    edx, dl
 00000E93  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 00000E9A  0F B6 55 F4	     2	        movzx    edx, BYTE PTR @CatStr(_X,2)                      ; b3    / b1
 00000E9E  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 00000EA5  89 45 E8	     2	        mov      DWORD PTR @CatStr(_Y,1), eax                     ; a0
 00000EA8		     1	??0005:
				                
				        ; 04 AES_FROUND(X0,X1,X2,X3, Y0,Y1,Y2,Y3);
				        AES_ROUND _X, _Y, 0,1,2,3       
 00000EA8  83 45 DC 10	     1	        add      DWORD PTR _RK, 4*SIZEOF DWORD          ; RK += 4; ; ecx = RK           
 00000EAC  8B 4D DC	     1	        mov      ecx, DWORD PTR _RK                                  
 00000EAF  81 3D 00000004 R  1	        cmp      DWORD PTR aesMode, _ctxStruct.drk      ; Check: ENCRYPT / DECIPHER
	   00000100
 00000EB9  0F 84 00000108    1	        je       ??0006                                       
 00000EBF  8B 01	     2	        mov      eax, DWORD PTR [ecx+0*SIZEOF DWORD]              ; ecx = RK[0]
 00000EC1  8B 55 EC	     2	        mov      edx, DWORD PTR @CatStr(_Y,0)                     ; b0
 00000EC4  C1 EA 18	     2	        shr      edx, 24                        
 00000EC7  0F B6 D2	     2	        movzx    edx, dl
 00000ECA  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 00000ED1  8B 55 E8	     2	        mov      edx, DWORD PTR @CatStr(_Y,1)                     ; b1    / b3
 00000ED4  C1 EA 10	     2	        shr      edx, 16                        
 00000ED7  0F B6 D2	     2	        movzx    edx, dl
 00000EDA  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 00000EE1  8B 55 E4	     2	        mov      edx, DWORD PTR @CatStr(_Y,2)                     ; b2
 00000EE4  C1 EA 08	     2	        shr      edx, 8
 00000EE7  0F B6 D2	     2	        movzx    edx, dl
 00000EEA  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 00000EF1  0F B6 55 E0	     2	        movzx    edx, BYTE PTR @CatStr(_Y,3)                      ; b3    / b1
 00000EF5  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 00000EFC  89 45 FC	     2	        mov      DWORD PTR @CatStr(_X,0), eax                     ; a0
 00000EFF  8B 41 04	     2	        mov      eax, DWORD PTR [ecx+1*SIZEOF DWORD]              ; ecx = RK[0]
 00000F02  8B 55 E8	     2	        mov      edx, DWORD PTR @CatStr(_Y,1)                     ; b0
 00000F05  C1 EA 18	     2	        shr      edx, 24                        
 00000F08  0F B6 D2	     2	        movzx    edx, dl
 00000F0B  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 00000F12  8B 55 E4	     2	        mov      edx, DWORD PTR @CatStr(_Y,2)                     ; b1    / b3
 00000F15  C1 EA 10	     2	        shr      edx, 16                        
 00000F18  0F B6 D2	     2	        movzx    edx, dl
 00000F1B  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 00000F22  8B 55 E0	     2	        mov      edx, DWORD PTR @CatStr(_Y,3)                     ; b2
 00000F25  C1 EA 08	     2	        shr      edx, 8
 00000F28  0F B6 D2	     2	        movzx    edx, dl
 00000F2B  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 00000F32  0F B6 55 EC	     2	        movzx    edx, BYTE PTR @CatStr(_Y,0)                      ; b3    / b1
 00000F36  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 31 - 1


 00000F3D  89 45 F8	     2	        mov      DWORD PTR @CatStr(_X,1), eax                     ; a0
 00000F40  8B 41 08	     2	        mov      eax, DWORD PTR [ecx+2*SIZEOF DWORD]              ; ecx = RK[0]
 00000F43  8B 55 E4	     2	        mov      edx, DWORD PTR @CatStr(_Y,2)                     ; b0
 00000F46  C1 EA 18	     2	        shr      edx, 24                        
 00000F49  0F B6 D2	     2	        movzx    edx, dl
 00000F4C  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 00000F53  8B 55 E0	     2	        mov      edx, DWORD PTR @CatStr(_Y,3)                     ; b1    / b3
 00000F56  C1 EA 10	     2	        shr      edx, 16                        
 00000F59  0F B6 D2	     2	        movzx    edx, dl
 00000F5C  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 00000F63  8B 55 EC	     2	        mov      edx, DWORD PTR @CatStr(_Y,0)                     ; b2
 00000F66  C1 EA 08	     2	        shr      edx, 8
 00000F69  0F B6 D2	     2	        movzx    edx, dl
 00000F6C  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 00000F73  0F B6 55 E8	     2	        movzx    edx, BYTE PTR @CatStr(_Y,1)                      ; b3    / b1
 00000F77  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 00000F7E  89 45 F4	     2	        mov      DWORD PTR @CatStr(_X,2), eax                     ; a0
 00000F81  8B 41 0C	     2	        mov      eax, DWORD PTR [ecx+3*SIZEOF DWORD]              ; ecx = RK[0]
 00000F84  8B 55 E0	     2	        mov      edx, DWORD PTR @CatStr(_Y,3)                     ; b0
 00000F87  C1 EA 18	     2	        shr      edx, 24                        
 00000F8A  0F B6 D2	     2	        movzx    edx, dl
 00000F8D  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 00000F94  8B 55 EC	     2	        mov      edx, DWORD PTR @CatStr(_Y,0)                     ; b1    / b3
 00000F97  C1 EA 10	     2	        shr      edx, 16                        
 00000F9A  0F B6 D2	     2	        movzx    edx, dl
 00000F9D  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 00000FA4  8B 55 E8	     2	        mov      edx, DWORD PTR @CatStr(_Y,1)                     ; b2
 00000FA7  C1 EA 08	     2	        shr      edx, 8
 00000FAA  0F B6 D2	     2	        movzx    edx, dl
 00000FAD  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 00000FB4  0F B6 55 E4	     2	        movzx    edx, BYTE PTR @CatStr(_Y,2)                      ; b3    / b1
 00000FB8  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 00000FBF  89 45 F0	     2	        mov      DWORD PTR @CatStr(_X,3), eax                     ; a0
 00000FC2  E9 00000103	     1	        jmp      ??0007
 00000FC7		     1	??0006:                                                       ; Decipher  
 00000FC7  8B 01	     2	        mov      eax, DWORD PTR [ecx+0*SIZEOF DWORD]              ; ecx = RK[0]
 00000FC9  8B 55 EC	     2	        mov      edx, DWORD PTR @CatStr(_Y,0)                     ; b0
 00000FCC  C1 EA 18	     2	        shr      edx, 24                        
 00000FCF  0F B6 D2	     2	        movzx    edx, dl
 00000FD2  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 00000FD9  8B 55 E0	     2	        mov      edx, DWORD PTR @CatStr(_Y,3)                     ; b1    / b3
 00000FDC  C1 EA 10	     2	        shr      edx, 16                        
 00000FDF  0F B6 D2	     2	        movzx    edx, dl
 00000FE2  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 00000FE9  8B 55 E4	     2	        mov      edx, DWORD PTR @CatStr(_Y,2)                     ; b2
 00000FEC  C1 EA 08	     2	        shr      edx, 8
 00000FEF  0F B6 D2	     2	        movzx    edx, dl
 00000FF2  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 00000FF9  0F B6 55 E8	     2	        movzx    edx, BYTE PTR @CatStr(_Y,1)                      ; b3    / b1
 00000FFD  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 00001004  89 45 FC	     2	        mov      DWORD PTR @CatStr(_X,0), eax                     ; a0
 00001007  8B 41 0C	     2	        mov      eax, DWORD PTR [ecx+3*SIZEOF DWORD]              ; ecx = RK[0]
 0000100A  8B 55 E0	     2	        mov      edx, DWORD PTR @CatStr(_Y,3)                     ; b0
 0000100D  C1 EA 18	     2	        shr      edx, 24                        
 00001010  0F B6 D2	     2	        movzx    edx, dl
 00001013  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 0000101A  8B 55 E4	     2	        mov      edx, DWORD PTR @CatStr(_Y,2)                     ; b1    / b3
 0000101D  C1 EA 10	     2	        shr      edx, 16                        
 00001020  0F B6 D2	     2	        movzx    edx, dl
 00001023  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 0000102A  8B 55 E8	     2	        mov      edx, DWORD PTR @CatStr(_Y,1)                     ; b2
 0000102D  C1 EA 08	     2	        shr      edx, 8
 00001030  0F B6 D2	     2	        movzx    edx, dl
 00001033  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 0000103A  0F B6 55 EC	     2	        movzx    edx, BYTE PTR @CatStr(_Y,0)                      ; b3    / b1
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 32 - 1


 0000103E  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 00001045  89 45 F0	     2	        mov      DWORD PTR @CatStr(_X,3), eax                     ; a0
 00001048  8B 41 08	     2	        mov      eax, DWORD PTR [ecx+2*SIZEOF DWORD]              ; ecx = RK[0]
 0000104B  8B 55 E4	     2	        mov      edx, DWORD PTR @CatStr(_Y,2)                     ; b0
 0000104E  C1 EA 18	     2	        shr      edx, 24                        
 00001051  0F B6 D2	     2	        movzx    edx, dl
 00001054  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 0000105B  8B 55 E8	     2	        mov      edx, DWORD PTR @CatStr(_Y,1)                     ; b1    / b3
 0000105E  C1 EA 10	     2	        shr      edx, 16                        
 00001061  0F B6 D2	     2	        movzx    edx, dl
 00001064  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 0000106B  8B 55 EC	     2	        mov      edx, DWORD PTR @CatStr(_Y,0)                     ; b2
 0000106E  C1 EA 08	     2	        shr      edx, 8
 00001071  0F B6 D2	     2	        movzx    edx, dl
 00001074  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 0000107B  0F B6 55 E0	     2	        movzx    edx, BYTE PTR @CatStr(_Y,3)                      ; b3    / b1
 0000107F  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 00001086  89 45 F4	     2	        mov      DWORD PTR @CatStr(_X,2), eax                     ; a0
 00001089  8B 41 04	     2	        mov      eax, DWORD PTR [ecx+1*SIZEOF DWORD]              ; ecx = RK[0]
 0000108C  8B 55 E8	     2	        mov      edx, DWORD PTR @CatStr(_Y,1)                     ; b0
 0000108F  C1 EA 18	     2	        shr      edx, 24                        
 00001092  0F B6 D2	     2	        movzx    edx, dl
 00001095  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 0000109C  8B 55 EC	     2	        mov      edx, DWORD PTR @CatStr(_Y,0)                     ; b1    / b3
 0000109F  C1 EA 10	     2	        shr      edx, 16                        
 000010A2  0F B6 D2	     2	        movzx    edx, dl
 000010A5  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 000010AC  8B 55 E0	     2	        mov      edx, DWORD PTR @CatStr(_Y,3)                     ; b2
 000010AF  C1 EA 08	     2	        shr      edx, 8
 000010B2  0F B6 D2	     2	        movzx    edx, dl
 000010B5  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 000010BC  0F B6 55 E4	     2	        movzx    edx, BYTE PTR @CatStr(_Y,2)                      ; b3    / b1
 000010C0  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 000010C7  89 45 F8	     2	        mov      DWORD PTR @CatStr(_X,1), eax                     ; a0
 000010CA		     1	??0007:
				                
				        ; 05 AES_FROUND(Y0,Y1,Y2,Y3, X0,X1,X2,X3);
				        AES_ROUND _Y, _X, 0,1,2,3                           
 000010CA  83 45 DC 10	     1	        add      DWORD PTR _RK, 4*SIZEOF DWORD          ; RK += 4; ; ecx = RK           
 000010CE  8B 4D DC	     1	        mov      ecx, DWORD PTR _RK                                  
 000010D1  81 3D 00000004 R  1	        cmp      DWORD PTR aesMode, _ctxStruct.drk      ; Check: ENCRYPT / DECIPHER
	   00000100
 000010DB  0F 84 00000108    1	        je       ??0008                                       
 000010E1  8B 01	     2	        mov      eax, DWORD PTR [ecx+0*SIZEOF DWORD]              ; ecx = RK[0]
 000010E3  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b0
 000010E6  C1 EA 18	     2	        shr      edx, 24                        
 000010E9  0F B6 D2	     2	        movzx    edx, dl
 000010EC  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 000010F3  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b1    / b3
 000010F6  C1 EA 10	     2	        shr      edx, 16                        
 000010F9  0F B6 D2	     2	        movzx    edx, dl
 000010FC  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 00001103  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b2
 00001106  C1 EA 08	     2	        shr      edx, 8
 00001109  0F B6 D2	     2	        movzx    edx, dl
 0000110C  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 00001113  0F B6 55 F0	     2	        movzx    edx, BYTE PTR @CatStr(_X,3)                      ; b3    / b1
 00001117  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 0000111E  89 45 EC	     2	        mov      DWORD PTR @CatStr(_Y,0), eax                     ; a0
 00001121  8B 41 04	     2	        mov      eax, DWORD PTR [ecx+1*SIZEOF DWORD]              ; ecx = RK[0]
 00001124  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b0
 00001127  C1 EA 18	     2	        shr      edx, 24                        
 0000112A  0F B6 D2	     2	        movzx    edx, dl
 0000112D  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 00001134  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b1    / b3
 00001137  C1 EA 10	     2	        shr      edx, 16                        
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 33 - 1


 0000113A  0F B6 D2	     2	        movzx    edx, dl
 0000113D  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 00001144  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b2
 00001147  C1 EA 08	     2	        shr      edx, 8
 0000114A  0F B6 D2	     2	        movzx    edx, dl
 0000114D  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 00001154  0F B6 55 FC	     2	        movzx    edx, BYTE PTR @CatStr(_X,0)                      ; b3    / b1
 00001158  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 0000115F  89 45 E8	     2	        mov      DWORD PTR @CatStr(_Y,1), eax                     ; a0
 00001162  8B 41 08	     2	        mov      eax, DWORD PTR [ecx+2*SIZEOF DWORD]              ; ecx = RK[0]
 00001165  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b0
 00001168  C1 EA 18	     2	        shr      edx, 24                        
 0000116B  0F B6 D2	     2	        movzx    edx, dl
 0000116E  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 00001175  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b1    / b3
 00001178  C1 EA 10	     2	        shr      edx, 16                        
 0000117B  0F B6 D2	     2	        movzx    edx, dl
 0000117E  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 00001185  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b2
 00001188  C1 EA 08	     2	        shr      edx, 8
 0000118B  0F B6 D2	     2	        movzx    edx, dl
 0000118E  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 00001195  0F B6 55 F8	     2	        movzx    edx, BYTE PTR @CatStr(_X,1)                      ; b3    / b1
 00001199  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 000011A0  89 45 E4	     2	        mov      DWORD PTR @CatStr(_Y,2), eax                     ; a0
 000011A3  8B 41 0C	     2	        mov      eax, DWORD PTR [ecx+3*SIZEOF DWORD]              ; ecx = RK[0]
 000011A6  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b0
 000011A9  C1 EA 18	     2	        shr      edx, 24                        
 000011AC  0F B6 D2	     2	        movzx    edx, dl
 000011AF  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 000011B6  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b1    / b3
 000011B9  C1 EA 10	     2	        shr      edx, 16                        
 000011BC  0F B6 D2	     2	        movzx    edx, dl
 000011BF  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 000011C6  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b2
 000011C9  C1 EA 08	     2	        shr      edx, 8
 000011CC  0F B6 D2	     2	        movzx    edx, dl
 000011CF  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 000011D6  0F B6 55 F4	     2	        movzx    edx, BYTE PTR @CatStr(_X,2)                      ; b3    / b1
 000011DA  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 000011E1  89 45 E0	     2	        mov      DWORD PTR @CatStr(_Y,3), eax                     ; a0
 000011E4  E9 00000103	     1	        jmp      ??0009
 000011E9		     1	??0008:                                                       ; Decipher  
 000011E9  8B 01	     2	        mov      eax, DWORD PTR [ecx+0*SIZEOF DWORD]              ; ecx = RK[0]
 000011EB  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b0
 000011EE  C1 EA 18	     2	        shr      edx, 24                        
 000011F1  0F B6 D2	     2	        movzx    edx, dl
 000011F4  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 000011FB  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b1    / b3
 000011FE  C1 EA 10	     2	        shr      edx, 16                        
 00001201  0F B6 D2	     2	        movzx    edx, dl
 00001204  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 0000120B  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b2
 0000120E  C1 EA 08	     2	        shr      edx, 8
 00001211  0F B6 D2	     2	        movzx    edx, dl
 00001214  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 0000121B  0F B6 55 F8	     2	        movzx    edx, BYTE PTR @CatStr(_X,1)                      ; b3    / b1
 0000121F  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 00001226  89 45 EC	     2	        mov      DWORD PTR @CatStr(_Y,0), eax                     ; a0
 00001229  8B 41 0C	     2	        mov      eax, DWORD PTR [ecx+3*SIZEOF DWORD]              ; ecx = RK[0]
 0000122C  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b0
 0000122F  C1 EA 18	     2	        shr      edx, 24                        
 00001232  0F B6 D2	     2	        movzx    edx, dl
 00001235  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 34 - 1


 0000123C  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b1    / b3
 0000123F  C1 EA 10	     2	        shr      edx, 16                        
 00001242  0F B6 D2	     2	        movzx    edx, dl
 00001245  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 0000124C  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b2
 0000124F  C1 EA 08	     2	        shr      edx, 8
 00001252  0F B6 D2	     2	        movzx    edx, dl
 00001255  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 0000125C  0F B6 55 FC	     2	        movzx    edx, BYTE PTR @CatStr(_X,0)                      ; b3    / b1
 00001260  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 00001267  89 45 E0	     2	        mov      DWORD PTR @CatStr(_Y,3), eax                     ; a0
 0000126A  8B 41 08	     2	        mov      eax, DWORD PTR [ecx+2*SIZEOF DWORD]              ; ecx = RK[0]
 0000126D  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b0
 00001270  C1 EA 18	     2	        shr      edx, 24                        
 00001273  0F B6 D2	     2	        movzx    edx, dl
 00001276  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 0000127D  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b1    / b3
 00001280  C1 EA 10	     2	        shr      edx, 16                        
 00001283  0F B6 D2	     2	        movzx    edx, dl
 00001286  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 0000128D  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b2
 00001290  C1 EA 08	     2	        shr      edx, 8
 00001293  0F B6 D2	     2	        movzx    edx, dl
 00001296  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 0000129D  0F B6 55 F0	     2	        movzx    edx, BYTE PTR @CatStr(_X,3)                      ; b3    / b1
 000012A1  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 000012A8  89 45 E4	     2	        mov      DWORD PTR @CatStr(_Y,2), eax                     ; a0
 000012AB  8B 41 04	     2	        mov      eax, DWORD PTR [ecx+1*SIZEOF DWORD]              ; ecx = RK[0]
 000012AE  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b0
 000012B1  C1 EA 18	     2	        shr      edx, 24                        
 000012B4  0F B6 D2	     2	        movzx    edx, dl
 000012B7  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 000012BE  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b1    / b3
 000012C1  C1 EA 10	     2	        shr      edx, 16                        
 000012C4  0F B6 D2	     2	        movzx    edx, dl
 000012C7  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 000012CE  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b2
 000012D1  C1 EA 08	     2	        shr      edx, 8
 000012D4  0F B6 D2	     2	        movzx    edx, dl
 000012D7  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 000012DE  0F B6 55 F4	     2	        movzx    edx, BYTE PTR @CatStr(_X,2)                      ; b3    / b1
 000012E2  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 000012E9  89 45 E8	     2	        mov      DWORD PTR @CatStr(_Y,1), eax                     ; a0
 000012EC		     1	??0009:
				                
				        ; 06 AES_FROUND(X0,X1,X2,X3, Y0,Y1,Y2,Y3);
				        AES_ROUND _X, _Y, 0,1,2,3       
 000012EC  83 45 DC 10	     1	        add      DWORD PTR _RK, 4*SIZEOF DWORD          ; RK += 4; ; ecx = RK           
 000012F0  8B 4D DC	     1	        mov      ecx, DWORD PTR _RK                                  
 000012F3  81 3D 00000004 R  1	        cmp      DWORD PTR aesMode, _ctxStruct.drk      ; Check: ENCRYPT / DECIPHER
	   00000100
 000012FD  0F 84 00000108    1	        je       ??000A                                       
 00001303  8B 01	     2	        mov      eax, DWORD PTR [ecx+0*SIZEOF DWORD]              ; ecx = RK[0]
 00001305  8B 55 EC	     2	        mov      edx, DWORD PTR @CatStr(_Y,0)                     ; b0
 00001308  C1 EA 18	     2	        shr      edx, 24                        
 0000130B  0F B6 D2	     2	        movzx    edx, dl
 0000130E  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 00001315  8B 55 E8	     2	        mov      edx, DWORD PTR @CatStr(_Y,1)                     ; b1    / b3
 00001318  C1 EA 10	     2	        shr      edx, 16                        
 0000131B  0F B6 D2	     2	        movzx    edx, dl
 0000131E  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 00001325  8B 55 E4	     2	        mov      edx, DWORD PTR @CatStr(_Y,2)                     ; b2
 00001328  C1 EA 08	     2	        shr      edx, 8
 0000132B  0F B6 D2	     2	        movzx    edx, dl
 0000132E  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 00001335  0F B6 55 E0	     2	        movzx    edx, BYTE PTR @CatStr(_Y,3)                      ; b3    / b1
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 35 - 1


 00001339  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 00001340  89 45 FC	     2	        mov      DWORD PTR @CatStr(_X,0), eax                     ; a0
 00001343  8B 41 04	     2	        mov      eax, DWORD PTR [ecx+1*SIZEOF DWORD]              ; ecx = RK[0]
 00001346  8B 55 E8	     2	        mov      edx, DWORD PTR @CatStr(_Y,1)                     ; b0
 00001349  C1 EA 18	     2	        shr      edx, 24                        
 0000134C  0F B6 D2	     2	        movzx    edx, dl
 0000134F  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 00001356  8B 55 E4	     2	        mov      edx, DWORD PTR @CatStr(_Y,2)                     ; b1    / b3
 00001359  C1 EA 10	     2	        shr      edx, 16                        
 0000135C  0F B6 D2	     2	        movzx    edx, dl
 0000135F  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 00001366  8B 55 E0	     2	        mov      edx, DWORD PTR @CatStr(_Y,3)                     ; b2
 00001369  C1 EA 08	     2	        shr      edx, 8
 0000136C  0F B6 D2	     2	        movzx    edx, dl
 0000136F  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 00001376  0F B6 55 EC	     2	        movzx    edx, BYTE PTR @CatStr(_Y,0)                      ; b3    / b1
 0000137A  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 00001381  89 45 F8	     2	        mov      DWORD PTR @CatStr(_X,1), eax                     ; a0
 00001384  8B 41 08	     2	        mov      eax, DWORD PTR [ecx+2*SIZEOF DWORD]              ; ecx = RK[0]
 00001387  8B 55 E4	     2	        mov      edx, DWORD PTR @CatStr(_Y,2)                     ; b0
 0000138A  C1 EA 18	     2	        shr      edx, 24                        
 0000138D  0F B6 D2	     2	        movzx    edx, dl
 00001390  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 00001397  8B 55 E0	     2	        mov      edx, DWORD PTR @CatStr(_Y,3)                     ; b1    / b3
 0000139A  C1 EA 10	     2	        shr      edx, 16                        
 0000139D  0F B6 D2	     2	        movzx    edx, dl
 000013A0  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 000013A7  8B 55 EC	     2	        mov      edx, DWORD PTR @CatStr(_Y,0)                     ; b2
 000013AA  C1 EA 08	     2	        shr      edx, 8
 000013AD  0F B6 D2	     2	        movzx    edx, dl
 000013B0  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 000013B7  0F B6 55 E8	     2	        movzx    edx, BYTE PTR @CatStr(_Y,1)                      ; b3    / b1
 000013BB  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 000013C2  89 45 F4	     2	        mov      DWORD PTR @CatStr(_X,2), eax                     ; a0
 000013C5  8B 41 0C	     2	        mov      eax, DWORD PTR [ecx+3*SIZEOF DWORD]              ; ecx = RK[0]
 000013C8  8B 55 E0	     2	        mov      edx, DWORD PTR @CatStr(_Y,3)                     ; b0
 000013CB  C1 EA 18	     2	        shr      edx, 24                        
 000013CE  0F B6 D2	     2	        movzx    edx, dl
 000013D1  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 000013D8  8B 55 EC	     2	        mov      edx, DWORD PTR @CatStr(_Y,0)                     ; b1    / b3
 000013DB  C1 EA 10	     2	        shr      edx, 16                        
 000013DE  0F B6 D2	     2	        movzx    edx, dl
 000013E1  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 000013E8  8B 55 E8	     2	        mov      edx, DWORD PTR @CatStr(_Y,1)                     ; b2
 000013EB  C1 EA 08	     2	        shr      edx, 8
 000013EE  0F B6 D2	     2	        movzx    edx, dl
 000013F1  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 000013F8  0F B6 55 E4	     2	        movzx    edx, BYTE PTR @CatStr(_Y,2)                      ; b3    / b1
 000013FC  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 00001403  89 45 F0	     2	        mov      DWORD PTR @CatStr(_X,3), eax                     ; a0
 00001406  E9 00000103	     1	        jmp      ??000B
 0000140B		     1	??000A:                                                       ; Decipher  
 0000140B  8B 01	     2	        mov      eax, DWORD PTR [ecx+0*SIZEOF DWORD]              ; ecx = RK[0]
 0000140D  8B 55 EC	     2	        mov      edx, DWORD PTR @CatStr(_Y,0)                     ; b0
 00001410  C1 EA 18	     2	        shr      edx, 24                        
 00001413  0F B6 D2	     2	        movzx    edx, dl
 00001416  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 0000141D  8B 55 E0	     2	        mov      edx, DWORD PTR @CatStr(_Y,3)                     ; b1    / b3
 00001420  C1 EA 10	     2	        shr      edx, 16                        
 00001423  0F B6 D2	     2	        movzx    edx, dl
 00001426  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 0000142D  8B 55 E4	     2	        mov      edx, DWORD PTR @CatStr(_Y,2)                     ; b2
 00001430  C1 EA 08	     2	        shr      edx, 8
 00001433  0F B6 D2	     2	        movzx    edx, dl
 00001436  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 36 - 1


	   00002A0C R
 0000143D  0F B6 55 E8	     2	        movzx    edx, BYTE PTR @CatStr(_Y,1)                      ; b3    / b1
 00001441  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 00001448  89 45 FC	     2	        mov      DWORD PTR @CatStr(_X,0), eax                     ; a0
 0000144B  8B 41 0C	     2	        mov      eax, DWORD PTR [ecx+3*SIZEOF DWORD]              ; ecx = RK[0]
 0000144E  8B 55 E0	     2	        mov      edx, DWORD PTR @CatStr(_Y,3)                     ; b0
 00001451  C1 EA 18	     2	        shr      edx, 24                        
 00001454  0F B6 D2	     2	        movzx    edx, dl
 00001457  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 0000145E  8B 55 E4	     2	        mov      edx, DWORD PTR @CatStr(_Y,2)                     ; b1    / b3
 00001461  C1 EA 10	     2	        shr      edx, 16                        
 00001464  0F B6 D2	     2	        movzx    edx, dl
 00001467  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 0000146E  8B 55 E8	     2	        mov      edx, DWORD PTR @CatStr(_Y,1)                     ; b2
 00001471  C1 EA 08	     2	        shr      edx, 8
 00001474  0F B6 D2	     2	        movzx    edx, dl
 00001477  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 0000147E  0F B6 55 EC	     2	        movzx    edx, BYTE PTR @CatStr(_Y,0)                      ; b3    / b1
 00001482  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 00001489  89 45 F0	     2	        mov      DWORD PTR @CatStr(_X,3), eax                     ; a0
 0000148C  8B 41 08	     2	        mov      eax, DWORD PTR [ecx+2*SIZEOF DWORD]              ; ecx = RK[0]
 0000148F  8B 55 E4	     2	        mov      edx, DWORD PTR @CatStr(_Y,2)                     ; b0
 00001492  C1 EA 18	     2	        shr      edx, 24                        
 00001495  0F B6 D2	     2	        movzx    edx, dl
 00001498  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 0000149F  8B 55 E8	     2	        mov      edx, DWORD PTR @CatStr(_Y,1)                     ; b1    / b3
 000014A2  C1 EA 10	     2	        shr      edx, 16                        
 000014A5  0F B6 D2	     2	        movzx    edx, dl
 000014A8  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 000014AF  8B 55 EC	     2	        mov      edx, DWORD PTR @CatStr(_Y,0)                     ; b2
 000014B2  C1 EA 08	     2	        shr      edx, 8
 000014B5  0F B6 D2	     2	        movzx    edx, dl
 000014B8  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 000014BF  0F B6 55 E0	     2	        movzx    edx, BYTE PTR @CatStr(_Y,3)                      ; b3    / b1
 000014C3  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 000014CA  89 45 F4	     2	        mov      DWORD PTR @CatStr(_X,2), eax                     ; a0
 000014CD  8B 41 04	     2	        mov      eax, DWORD PTR [ecx+1*SIZEOF DWORD]              ; ecx = RK[0]
 000014D0  8B 55 E8	     2	        mov      edx, DWORD PTR @CatStr(_Y,1)                     ; b0
 000014D3  C1 EA 18	     2	        shr      edx, 24                        
 000014D6  0F B6 D2	     2	        movzx    edx, dl
 000014D9  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 000014E0  8B 55 EC	     2	        mov      edx, DWORD PTR @CatStr(_Y,0)                     ; b1    / b3
 000014E3  C1 EA 10	     2	        shr      edx, 16                        
 000014E6  0F B6 D2	     2	        movzx    edx, dl
 000014E9  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 000014F0  8B 55 E0	     2	        mov      edx, DWORD PTR @CatStr(_Y,3)                     ; b2
 000014F3  C1 EA 08	     2	        shr      edx, 8
 000014F6  0F B6 D2	     2	        movzx    edx, dl
 000014F9  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 00001500  0F B6 55 E4	     2	        movzx    edx, BYTE PTR @CatStr(_Y,2)                      ; b3    / b1
 00001504  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 0000150B  89 45 F8	     2	        mov      DWORD PTR @CatStr(_X,1), eax                     ; a0
 0000150E		     1	??000B:
				                
				        ; 07 AES_FROUND(Y0,Y1,Y2,Y3, X0,X1,X2,X3);
				        AES_ROUND _Y, _X, 0,1,2,3       
 0000150E  83 45 DC 10	     1	        add      DWORD PTR _RK, 4*SIZEOF DWORD          ; RK += 4; ; ecx = RK           
 00001512  8B 4D DC	     1	        mov      ecx, DWORD PTR _RK                                  
 00001515  81 3D 00000004 R  1	        cmp      DWORD PTR aesMode, _ctxStruct.drk      ; Check: ENCRYPT / DECIPHER
	   00000100
 0000151F  0F 84 00000108    1	        je       ??000C                                       
 00001525  8B 01	     2	        mov      eax, DWORD PTR [ecx+0*SIZEOF DWORD]              ; ecx = RK[0]
 00001527  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b0
 0000152A  C1 EA 18	     2	        shr      edx, 24                        
 0000152D  0F B6 D2	     2	        movzx    edx, dl
 00001530  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 37 - 1


 00001537  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b1    / b3
 0000153A  C1 EA 10	     2	        shr      edx, 16                        
 0000153D  0F B6 D2	     2	        movzx    edx, dl
 00001540  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 00001547  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b2
 0000154A  C1 EA 08	     2	        shr      edx, 8
 0000154D  0F B6 D2	     2	        movzx    edx, dl
 00001550  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 00001557  0F B6 55 F0	     2	        movzx    edx, BYTE PTR @CatStr(_X,3)                      ; b3    / b1
 0000155B  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 00001562  89 45 EC	     2	        mov      DWORD PTR @CatStr(_Y,0), eax                     ; a0
 00001565  8B 41 04	     2	        mov      eax, DWORD PTR [ecx+1*SIZEOF DWORD]              ; ecx = RK[0]
 00001568  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b0
 0000156B  C1 EA 18	     2	        shr      edx, 24                        
 0000156E  0F B6 D2	     2	        movzx    edx, dl
 00001571  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 00001578  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b1    / b3
 0000157B  C1 EA 10	     2	        shr      edx, 16                        
 0000157E  0F B6 D2	     2	        movzx    edx, dl
 00001581  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 00001588  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b2
 0000158B  C1 EA 08	     2	        shr      edx, 8
 0000158E  0F B6 D2	     2	        movzx    edx, dl
 00001591  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 00001598  0F B6 55 FC	     2	        movzx    edx, BYTE PTR @CatStr(_X,0)                      ; b3    / b1
 0000159C  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 000015A3  89 45 E8	     2	        mov      DWORD PTR @CatStr(_Y,1), eax                     ; a0
 000015A6  8B 41 08	     2	        mov      eax, DWORD PTR [ecx+2*SIZEOF DWORD]              ; ecx = RK[0]
 000015A9  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b0
 000015AC  C1 EA 18	     2	        shr      edx, 24                        
 000015AF  0F B6 D2	     2	        movzx    edx, dl
 000015B2  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 000015B9  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b1    / b3
 000015BC  C1 EA 10	     2	        shr      edx, 16                        
 000015BF  0F B6 D2	     2	        movzx    edx, dl
 000015C2  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 000015C9  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b2
 000015CC  C1 EA 08	     2	        shr      edx, 8
 000015CF  0F B6 D2	     2	        movzx    edx, dl
 000015D2  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 000015D9  0F B6 55 F8	     2	        movzx    edx, BYTE PTR @CatStr(_X,1)                      ; b3    / b1
 000015DD  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 000015E4  89 45 E4	     2	        mov      DWORD PTR @CatStr(_Y,2), eax                     ; a0
 000015E7  8B 41 0C	     2	        mov      eax, DWORD PTR [ecx+3*SIZEOF DWORD]              ; ecx = RK[0]
 000015EA  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b0
 000015ED  C1 EA 18	     2	        shr      edx, 24                        
 000015F0  0F B6 D2	     2	        movzx    edx, dl
 000015F3  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 000015FA  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b1    / b3
 000015FD  C1 EA 10	     2	        shr      edx, 16                        
 00001600  0F B6 D2	     2	        movzx    edx, dl
 00001603  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 0000160A  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b2
 0000160D  C1 EA 08	     2	        shr      edx, 8
 00001610  0F B6 D2	     2	        movzx    edx, dl
 00001613  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 0000161A  0F B6 55 F4	     2	        movzx    edx, BYTE PTR @CatStr(_X,2)                      ; b3    / b1
 0000161E  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 00001625  89 45 E0	     2	        mov      DWORD PTR @CatStr(_Y,3), eax                     ; a0
 00001628  E9 00000103	     1	        jmp      ??000D
 0000162D		     1	??000C:                                                       ; Decipher  
 0000162D  8B 01	     2	        mov      eax, DWORD PTR [ecx+0*SIZEOF DWORD]              ; ecx = RK[0]
 0000162F  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b0
 00001632  C1 EA 18	     2	        shr      edx, 24                        
 00001635  0F B6 D2	     2	        movzx    edx, dl
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 38 - 1


 00001638  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 0000163F  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b1    / b3
 00001642  C1 EA 10	     2	        shr      edx, 16                        
 00001645  0F B6 D2	     2	        movzx    edx, dl
 00001648  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 0000164F  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b2
 00001652  C1 EA 08	     2	        shr      edx, 8
 00001655  0F B6 D2	     2	        movzx    edx, dl
 00001658  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 0000165F  0F B6 55 F8	     2	        movzx    edx, BYTE PTR @CatStr(_X,1)                      ; b3    / b1
 00001663  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 0000166A  89 45 EC	     2	        mov      DWORD PTR @CatStr(_Y,0), eax                     ; a0
 0000166D  8B 41 0C	     2	        mov      eax, DWORD PTR [ecx+3*SIZEOF DWORD]              ; ecx = RK[0]
 00001670  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b0
 00001673  C1 EA 18	     2	        shr      edx, 24                        
 00001676  0F B6 D2	     2	        movzx    edx, dl
 00001679  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 00001680  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b1    / b3
 00001683  C1 EA 10	     2	        shr      edx, 16                        
 00001686  0F B6 D2	     2	        movzx    edx, dl
 00001689  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 00001690  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b2
 00001693  C1 EA 08	     2	        shr      edx, 8
 00001696  0F B6 D2	     2	        movzx    edx, dl
 00001699  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 000016A0  0F B6 55 FC	     2	        movzx    edx, BYTE PTR @CatStr(_X,0)                      ; b3    / b1
 000016A4  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 000016AB  89 45 E0	     2	        mov      DWORD PTR @CatStr(_Y,3), eax                     ; a0
 000016AE  8B 41 08	     2	        mov      eax, DWORD PTR [ecx+2*SIZEOF DWORD]              ; ecx = RK[0]
 000016B1  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b0
 000016B4  C1 EA 18	     2	        shr      edx, 24                        
 000016B7  0F B6 D2	     2	        movzx    edx, dl
 000016BA  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 000016C1  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b1    / b3
 000016C4  C1 EA 10	     2	        shr      edx, 16                        
 000016C7  0F B6 D2	     2	        movzx    edx, dl
 000016CA  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 000016D1  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b2
 000016D4  C1 EA 08	     2	        shr      edx, 8
 000016D7  0F B6 D2	     2	        movzx    edx, dl
 000016DA  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 000016E1  0F B6 55 F0	     2	        movzx    edx, BYTE PTR @CatStr(_X,3)                      ; b3    / b1
 000016E5  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 000016EC  89 45 E4	     2	        mov      DWORD PTR @CatStr(_Y,2), eax                     ; a0
 000016EF  8B 41 04	     2	        mov      eax, DWORD PTR [ecx+1*SIZEOF DWORD]              ; ecx = RK[0]
 000016F2  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b0
 000016F5  C1 EA 18	     2	        shr      edx, 24                        
 000016F8  0F B6 D2	     2	        movzx    edx, dl
 000016FB  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 00001702  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b1    / b3
 00001705  C1 EA 10	     2	        shr      edx, 16                        
 00001708  0F B6 D2	     2	        movzx    edx, dl
 0000170B  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 00001712  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b2
 00001715  C1 EA 08	     2	        shr      edx, 8
 00001718  0F B6 D2	     2	        movzx    edx, dl
 0000171B  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 00001722  0F B6 55 F4	     2	        movzx    edx, BYTE PTR @CatStr(_X,2)                      ; b3    / b1
 00001726  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 0000172D  89 45 E8	     2	        mov      DWORD PTR @CatStr(_Y,1), eax                     ; a0
 00001730		     1	??000D:
				                
				        ; 08 AES_FROUND(X0,X1,X2,X3, Y0,Y1,Y2,Y3);
				        AES_ROUND _X, _Y, 0,1,2,3       
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 39 - 1


 00001730  83 45 DC 10	     1	        add      DWORD PTR _RK, 4*SIZEOF DWORD          ; RK += 4; ; ecx = RK           
 00001734  8B 4D DC	     1	        mov      ecx, DWORD PTR _RK                                  
 00001737  81 3D 00000004 R  1	        cmp      DWORD PTR aesMode, _ctxStruct.drk      ; Check: ENCRYPT / DECIPHER
	   00000100
 00001741  0F 84 00000108    1	        je       ??000E                                       
 00001747  8B 01	     2	        mov      eax, DWORD PTR [ecx+0*SIZEOF DWORD]              ; ecx = RK[0]
 00001749  8B 55 EC	     2	        mov      edx, DWORD PTR @CatStr(_Y,0)                     ; b0
 0000174C  C1 EA 18	     2	        shr      edx, 24                        
 0000174F  0F B6 D2	     2	        movzx    edx, dl
 00001752  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 00001759  8B 55 E8	     2	        mov      edx, DWORD PTR @CatStr(_Y,1)                     ; b1    / b3
 0000175C  C1 EA 10	     2	        shr      edx, 16                        
 0000175F  0F B6 D2	     2	        movzx    edx, dl
 00001762  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 00001769  8B 55 E4	     2	        mov      edx, DWORD PTR @CatStr(_Y,2)                     ; b2
 0000176C  C1 EA 08	     2	        shr      edx, 8
 0000176F  0F B6 D2	     2	        movzx    edx, dl
 00001772  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 00001779  0F B6 55 E0	     2	        movzx    edx, BYTE PTR @CatStr(_Y,3)                      ; b3    / b1
 0000177D  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 00001784  89 45 FC	     2	        mov      DWORD PTR @CatStr(_X,0), eax                     ; a0
 00001787  8B 41 04	     2	        mov      eax, DWORD PTR [ecx+1*SIZEOF DWORD]              ; ecx = RK[0]
 0000178A  8B 55 E8	     2	        mov      edx, DWORD PTR @CatStr(_Y,1)                     ; b0
 0000178D  C1 EA 18	     2	        shr      edx, 24                        
 00001790  0F B6 D2	     2	        movzx    edx, dl
 00001793  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 0000179A  8B 55 E4	     2	        mov      edx, DWORD PTR @CatStr(_Y,2)                     ; b1    / b3
 0000179D  C1 EA 10	     2	        shr      edx, 16                        
 000017A0  0F B6 D2	     2	        movzx    edx, dl
 000017A3  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 000017AA  8B 55 E0	     2	        mov      edx, DWORD PTR @CatStr(_Y,3)                     ; b2
 000017AD  C1 EA 08	     2	        shr      edx, 8
 000017B0  0F B6 D2	     2	        movzx    edx, dl
 000017B3  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 000017BA  0F B6 55 EC	     2	        movzx    edx, BYTE PTR @CatStr(_Y,0)                      ; b3    / b1
 000017BE  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 000017C5  89 45 F8	     2	        mov      DWORD PTR @CatStr(_X,1), eax                     ; a0
 000017C8  8B 41 08	     2	        mov      eax, DWORD PTR [ecx+2*SIZEOF DWORD]              ; ecx = RK[0]
 000017CB  8B 55 E4	     2	        mov      edx, DWORD PTR @CatStr(_Y,2)                     ; b0
 000017CE  C1 EA 18	     2	        shr      edx, 24                        
 000017D1  0F B6 D2	     2	        movzx    edx, dl
 000017D4  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 000017DB  8B 55 E0	     2	        mov      edx, DWORD PTR @CatStr(_Y,3)                     ; b1    / b3
 000017DE  C1 EA 10	     2	        shr      edx, 16                        
 000017E1  0F B6 D2	     2	        movzx    edx, dl
 000017E4  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 000017EB  8B 55 EC	     2	        mov      edx, DWORD PTR @CatStr(_Y,0)                     ; b2
 000017EE  C1 EA 08	     2	        shr      edx, 8
 000017F1  0F B6 D2	     2	        movzx    edx, dl
 000017F4  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 000017FB  0F B6 55 E8	     2	        movzx    edx, BYTE PTR @CatStr(_Y,1)                      ; b3    / b1
 000017FF  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 00001806  89 45 F4	     2	        mov      DWORD PTR @CatStr(_X,2), eax                     ; a0
 00001809  8B 41 0C	     2	        mov      eax, DWORD PTR [ecx+3*SIZEOF DWORD]              ; ecx = RK[0]
 0000180C  8B 55 E0	     2	        mov      edx, DWORD PTR @CatStr(_Y,3)                     ; b0
 0000180F  C1 EA 18	     2	        shr      edx, 24                        
 00001812  0F B6 D2	     2	        movzx    edx, dl
 00001815  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 0000181C  8B 55 EC	     2	        mov      edx, DWORD PTR @CatStr(_Y,0)                     ; b1    / b3
 0000181F  C1 EA 10	     2	        shr      edx, 16                        
 00001822  0F B6 D2	     2	        movzx    edx, dl
 00001825  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 0000182C  8B 55 E8	     2	        mov      edx, DWORD PTR @CatStr(_Y,1)                     ; b2
 0000182F  C1 EA 08	     2	        shr      edx, 8
 00001832  0F B6 D2	     2	        movzx    edx, dl
 00001835  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 40 - 1


	   0000160C R
 0000183C  0F B6 55 E4	     2	        movzx    edx, BYTE PTR @CatStr(_Y,2)                      ; b3    / b1
 00001840  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 00001847  89 45 F0	     2	        mov      DWORD PTR @CatStr(_X,3), eax                     ; a0
 0000184A  E9 00000103	     1	        jmp      ??000F
 0000184F		     1	??000E:                                                       ; Decipher  
 0000184F  8B 01	     2	        mov      eax, DWORD PTR [ecx+0*SIZEOF DWORD]              ; ecx = RK[0]
 00001851  8B 55 EC	     2	        mov      edx, DWORD PTR @CatStr(_Y,0)                     ; b0
 00001854  C1 EA 18	     2	        shr      edx, 24                        
 00001857  0F B6 D2	     2	        movzx    edx, dl
 0000185A  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 00001861  8B 55 E0	     2	        mov      edx, DWORD PTR @CatStr(_Y,3)                     ; b1    / b3
 00001864  C1 EA 10	     2	        shr      edx, 16                        
 00001867  0F B6 D2	     2	        movzx    edx, dl
 0000186A  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 00001871  8B 55 E4	     2	        mov      edx, DWORD PTR @CatStr(_Y,2)                     ; b2
 00001874  C1 EA 08	     2	        shr      edx, 8
 00001877  0F B6 D2	     2	        movzx    edx, dl
 0000187A  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 00001881  0F B6 55 E8	     2	        movzx    edx, BYTE PTR @CatStr(_Y,1)                      ; b3    / b1
 00001885  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 0000188C  89 45 FC	     2	        mov      DWORD PTR @CatStr(_X,0), eax                     ; a0
 0000188F  8B 41 0C	     2	        mov      eax, DWORD PTR [ecx+3*SIZEOF DWORD]              ; ecx = RK[0]
 00001892  8B 55 E0	     2	        mov      edx, DWORD PTR @CatStr(_Y,3)                     ; b0
 00001895  C1 EA 18	     2	        shr      edx, 24                        
 00001898  0F B6 D2	     2	        movzx    edx, dl
 0000189B  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 000018A2  8B 55 E4	     2	        mov      edx, DWORD PTR @CatStr(_Y,2)                     ; b1    / b3
 000018A5  C1 EA 10	     2	        shr      edx, 16                        
 000018A8  0F B6 D2	     2	        movzx    edx, dl
 000018AB  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 000018B2  8B 55 E8	     2	        mov      edx, DWORD PTR @CatStr(_Y,1)                     ; b2
 000018B5  C1 EA 08	     2	        shr      edx, 8
 000018B8  0F B6 D2	     2	        movzx    edx, dl
 000018BB  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 000018C2  0F B6 55 EC	     2	        movzx    edx, BYTE PTR @CatStr(_Y,0)                      ; b3    / b1
 000018C6  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 000018CD  89 45 F0	     2	        mov      DWORD PTR @CatStr(_X,3), eax                     ; a0
 000018D0  8B 41 08	     2	        mov      eax, DWORD PTR [ecx+2*SIZEOF DWORD]              ; ecx = RK[0]
 000018D3  8B 55 E4	     2	        mov      edx, DWORD PTR @CatStr(_Y,2)                     ; b0
 000018D6  C1 EA 18	     2	        shr      edx, 24                        
 000018D9  0F B6 D2	     2	        movzx    edx, dl
 000018DC  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 000018E3  8B 55 E8	     2	        mov      edx, DWORD PTR @CatStr(_Y,1)                     ; b1    / b3
 000018E6  C1 EA 10	     2	        shr      edx, 16                        
 000018E9  0F B6 D2	     2	        movzx    edx, dl
 000018EC  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 000018F3  8B 55 EC	     2	        mov      edx, DWORD PTR @CatStr(_Y,0)                     ; b2
 000018F6  C1 EA 08	     2	        shr      edx, 8
 000018F9  0F B6 D2	     2	        movzx    edx, dl
 000018FC  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 00001903  0F B6 55 E0	     2	        movzx    edx, BYTE PTR @CatStr(_Y,3)                      ; b3    / b1
 00001907  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 0000190E  89 45 F4	     2	        mov      DWORD PTR @CatStr(_X,2), eax                     ; a0
 00001911  8B 41 04	     2	        mov      eax, DWORD PTR [ecx+1*SIZEOF DWORD]              ; ecx = RK[0]
 00001914  8B 55 E8	     2	        mov      edx, DWORD PTR @CatStr(_Y,1)                     ; b0
 00001917  C1 EA 18	     2	        shr      edx, 24                        
 0000191A  0F B6 D2	     2	        movzx    edx, dl
 0000191D  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 00001924  8B 55 EC	     2	        mov      edx, DWORD PTR @CatStr(_Y,0)                     ; b1    / b3
 00001927  C1 EA 10	     2	        shr      edx, 16                        
 0000192A  0F B6 D2	     2	        movzx    edx, dl
 0000192D  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 00001934  8B 55 E0	     2	        mov      edx, DWORD PTR @CatStr(_Y,3)                     ; b2
 00001937  C1 EA 08	     2	        shr      edx, 8
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 41 - 1


 0000193A  0F B6 D2	     2	        movzx    edx, dl
 0000193D  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 00001944  0F B6 55 E4	     2	        movzx    edx, BYTE PTR @CatStr(_Y,2)                      ; b3    / b1
 00001948  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 0000194F  89 45 F8	     2	        mov      DWORD PTR @CatStr(_X,1), eax                     ; a0
 00001952		     1	??000F:
				                
				        ; 09 AES_FROUND(Y0,Y1,Y2,Y3, X0,X1,X2,X3);
				        AES_ROUND _Y, _X, 0,1,2,3       
 00001952  83 45 DC 10	     1	        add      DWORD PTR _RK, 4*SIZEOF DWORD          ; RK += 4; ; ecx = RK           
 00001956  8B 4D DC	     1	        mov      ecx, DWORD PTR _RK                                  
 00001959  81 3D 00000004 R  1	        cmp      DWORD PTR aesMode, _ctxStruct.drk      ; Check: ENCRYPT / DECIPHER
	   00000100
 00001963  0F 84 00000108    1	        je       ??0010                                       
 00001969  8B 01	     2	        mov      eax, DWORD PTR [ecx+0*SIZEOF DWORD]              ; ecx = RK[0]
 0000196B  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b0
 0000196E  C1 EA 18	     2	        shr      edx, 24                        
 00001971  0F B6 D2	     2	        movzx    edx, dl
 00001974  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 0000197B  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b1    / b3
 0000197E  C1 EA 10	     2	        shr      edx, 16                        
 00001981  0F B6 D2	     2	        movzx    edx, dl
 00001984  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 0000198B  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b2
 0000198E  C1 EA 08	     2	        shr      edx, 8
 00001991  0F B6 D2	     2	        movzx    edx, dl
 00001994  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 0000199B  0F B6 55 F0	     2	        movzx    edx, BYTE PTR @CatStr(_X,3)                      ; b3    / b1
 0000199F  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 000019A6  89 45 EC	     2	        mov      DWORD PTR @CatStr(_Y,0), eax                     ; a0
 000019A9  8B 41 04	     2	        mov      eax, DWORD PTR [ecx+1*SIZEOF DWORD]              ; ecx = RK[0]
 000019AC  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b0
 000019AF  C1 EA 18	     2	        shr      edx, 24                        
 000019B2  0F B6 D2	     2	        movzx    edx, dl
 000019B5  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 000019BC  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b1    / b3
 000019BF  C1 EA 10	     2	        shr      edx, 16                        
 000019C2  0F B6 D2	     2	        movzx    edx, dl
 000019C5  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 000019CC  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b2
 000019CF  C1 EA 08	     2	        shr      edx, 8
 000019D2  0F B6 D2	     2	        movzx    edx, dl
 000019D5  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 000019DC  0F B6 55 FC	     2	        movzx    edx, BYTE PTR @CatStr(_X,0)                      ; b3    / b1
 000019E0  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 000019E7  89 45 E8	     2	        mov      DWORD PTR @CatStr(_Y,1), eax                     ; a0
 000019EA  8B 41 08	     2	        mov      eax, DWORD PTR [ecx+2*SIZEOF DWORD]              ; ecx = RK[0]
 000019ED  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b0
 000019F0  C1 EA 18	     2	        shr      edx, 24                        
 000019F3  0F B6 D2	     2	        movzx    edx, dl
 000019F6  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 000019FD  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b1    / b3
 00001A00  C1 EA 10	     2	        shr      edx, 16                        
 00001A03  0F B6 D2	     2	        movzx    edx, dl
 00001A06  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 00001A0D  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b2
 00001A10  C1 EA 08	     2	        shr      edx, 8
 00001A13  0F B6 D2	     2	        movzx    edx, dl
 00001A16  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 00001A1D  0F B6 55 F8	     2	        movzx    edx, BYTE PTR @CatStr(_X,1)                      ; b3    / b1
 00001A21  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 00001A28  89 45 E4	     2	        mov      DWORD PTR @CatStr(_Y,2), eax                     ; a0
 00001A2B  8B 41 0C	     2	        mov      eax, DWORD PTR [ecx+3*SIZEOF DWORD]              ; ecx = RK[0]
 00001A2E  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b0
 00001A31  C1 EA 18	     2	        shr      edx, 24                        
 00001A34  0F B6 D2	     2	        movzx    edx, dl
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 42 - 1


 00001A37  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 00001A3E  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b1    / b3
 00001A41  C1 EA 10	     2	        shr      edx, 16                        
 00001A44  0F B6 D2	     2	        movzx    edx, dl
 00001A47  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 00001A4E  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b2
 00001A51  C1 EA 08	     2	        shr      edx, 8
 00001A54  0F B6 D2	     2	        movzx    edx, dl
 00001A57  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 00001A5E  0F B6 55 F4	     2	        movzx    edx, BYTE PTR @CatStr(_X,2)                      ; b3    / b1
 00001A62  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 00001A69  89 45 E0	     2	        mov      DWORD PTR @CatStr(_Y,3), eax                     ; a0
 00001A6C  E9 00000103	     1	        jmp      ??0011
 00001A71		     1	??0010:                                                       ; Decipher  
 00001A71  8B 01	     2	        mov      eax, DWORD PTR [ecx+0*SIZEOF DWORD]              ; ecx = RK[0]
 00001A73  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b0
 00001A76  C1 EA 18	     2	        shr      edx, 24                        
 00001A79  0F B6 D2	     2	        movzx    edx, dl
 00001A7C  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 00001A83  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b1    / b3
 00001A86  C1 EA 10	     2	        shr      edx, 16                        
 00001A89  0F B6 D2	     2	        movzx    edx, dl
 00001A8C  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 00001A93  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b2
 00001A96  C1 EA 08	     2	        shr      edx, 8
 00001A99  0F B6 D2	     2	        movzx    edx, dl
 00001A9C  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 00001AA3  0F B6 55 F8	     2	        movzx    edx, BYTE PTR @CatStr(_X,1)                      ; b3    / b1
 00001AA7  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 00001AAE  89 45 EC	     2	        mov      DWORD PTR @CatStr(_Y,0), eax                     ; a0
 00001AB1  8B 41 0C	     2	        mov      eax, DWORD PTR [ecx+3*SIZEOF DWORD]              ; ecx = RK[0]
 00001AB4  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b0
 00001AB7  C1 EA 18	     2	        shr      edx, 24                        
 00001ABA  0F B6 D2	     2	        movzx    edx, dl
 00001ABD  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 00001AC4  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b1    / b3
 00001AC7  C1 EA 10	     2	        shr      edx, 16                        
 00001ACA  0F B6 D2	     2	        movzx    edx, dl
 00001ACD  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 00001AD4  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b2
 00001AD7  C1 EA 08	     2	        shr      edx, 8
 00001ADA  0F B6 D2	     2	        movzx    edx, dl
 00001ADD  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 00001AE4  0F B6 55 FC	     2	        movzx    edx, BYTE PTR @CatStr(_X,0)                      ; b3    / b1
 00001AE8  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 00001AEF  89 45 E0	     2	        mov      DWORD PTR @CatStr(_Y,3), eax                     ; a0
 00001AF2  8B 41 08	     2	        mov      eax, DWORD PTR [ecx+2*SIZEOF DWORD]              ; ecx = RK[0]
 00001AF5  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b0
 00001AF8  C1 EA 18	     2	        shr      edx, 24                        
 00001AFB  0F B6 D2	     2	        movzx    edx, dl
 00001AFE  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 00001B05  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b1    / b3
 00001B08  C1 EA 10	     2	        shr      edx, 16                        
 00001B0B  0F B6 D2	     2	        movzx    edx, dl
 00001B0E  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 00001B15  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b2
 00001B18  C1 EA 08	     2	        shr      edx, 8
 00001B1B  0F B6 D2	     2	        movzx    edx, dl
 00001B1E  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 00001B25  0F B6 55 F0	     2	        movzx    edx, BYTE PTR @CatStr(_X,3)                      ; b3    / b1
 00001B29  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 00001B30  89 45 E4	     2	        mov      DWORD PTR @CatStr(_Y,2), eax                     ; a0
 00001B33  8B 41 04	     2	        mov      eax, DWORD PTR [ecx+1*SIZEOF DWORD]              ; ecx = RK[0]
 00001B36  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b0
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 43 - 1


 00001B39  C1 EA 18	     2	        shr      edx, 24                        
 00001B3C  0F B6 D2	     2	        movzx    edx, dl
 00001B3F  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 00001B46  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b1    / b3
 00001B49  C1 EA 10	     2	        shr      edx, 16                        
 00001B4C  0F B6 D2	     2	        movzx    edx, dl
 00001B4F  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 00001B56  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b2
 00001B59  C1 EA 08	     2	        shr      edx, 8
 00001B5C  0F B6 D2	     2	        movzx    edx, dl
 00001B5F  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 00001B66  0F B6 55 F4	     2	        movzx    edx, BYTE PTR @CatStr(_X,2)                      ; b3    / b1
 00001B6A  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 00001B71  89 45 E8	     2	        mov      DWORD PTR @CatStr(_Y,1), eax                     ; a0
 00001B74		     1	??0011:
				        
 00001B74  8B 4D 08		        mov      ecx, DWORD PTR _ctx                    ; if( ctx->nr == 10 )
 00001B77  83 B9 00000200	        cmp      DWORD PTR [ecx]._ctxStruct.rnr, 10     ; 128bit-key?   
	   0A
 00001B7E  0F 84 00000898	        je       @F                                     ; Last round = 10th Round.
				        
				        ; 10 AES_FROUND(X0,X1,X2,X3, Y0,Y1,Y2,Y3);
				        AES_ROUND _X, _Y, 0,1,2,3       
 00001B84  83 45 DC 10	     1	        add      DWORD PTR _RK, 4*SIZEOF DWORD          ; RK += 4; ; ecx = RK           
 00001B88  8B 4D DC	     1	        mov      ecx, DWORD PTR _RK                                  
 00001B8B  81 3D 00000004 R  1	        cmp      DWORD PTR aesMode, _ctxStruct.drk      ; Check: ENCRYPT / DECIPHER
	   00000100
 00001B95  0F 84 00000108    1	        je       ??0012                                       
 00001B9B  8B 01	     2	        mov      eax, DWORD PTR [ecx+0*SIZEOF DWORD]              ; ecx = RK[0]
 00001B9D  8B 55 EC	     2	        mov      edx, DWORD PTR @CatStr(_Y,0)                     ; b0
 00001BA0  C1 EA 18	     2	        shr      edx, 24                        
 00001BA3  0F B6 D2	     2	        movzx    edx, dl
 00001BA6  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 00001BAD  8B 55 E8	     2	        mov      edx, DWORD PTR @CatStr(_Y,1)                     ; b1    / b3
 00001BB0  C1 EA 10	     2	        shr      edx, 16                        
 00001BB3  0F B6 D2	     2	        movzx    edx, dl
 00001BB6  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 00001BBD  8B 55 E4	     2	        mov      edx, DWORD PTR @CatStr(_Y,2)                     ; b2
 00001BC0  C1 EA 08	     2	        shr      edx, 8
 00001BC3  0F B6 D2	     2	        movzx    edx, dl
 00001BC6  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 00001BCD  0F B6 55 E0	     2	        movzx    edx, BYTE PTR @CatStr(_Y,3)                      ; b3    / b1
 00001BD1  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 00001BD8  89 45 FC	     2	        mov      DWORD PTR @CatStr(_X,0), eax                     ; a0
 00001BDB  8B 41 04	     2	        mov      eax, DWORD PTR [ecx+1*SIZEOF DWORD]              ; ecx = RK[0]
 00001BDE  8B 55 E8	     2	        mov      edx, DWORD PTR @CatStr(_Y,1)                     ; b0
 00001BE1  C1 EA 18	     2	        shr      edx, 24                        
 00001BE4  0F B6 D2	     2	        movzx    edx, dl
 00001BE7  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 00001BEE  8B 55 E4	     2	        mov      edx, DWORD PTR @CatStr(_Y,2)                     ; b1    / b3
 00001BF1  C1 EA 10	     2	        shr      edx, 16                        
 00001BF4  0F B6 D2	     2	        movzx    edx, dl
 00001BF7  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 00001BFE  8B 55 E0	     2	        mov      edx, DWORD PTR @CatStr(_Y,3)                     ; b2
 00001C01  C1 EA 08	     2	        shr      edx, 8
 00001C04  0F B6 D2	     2	        movzx    edx, dl
 00001C07  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 00001C0E  0F B6 55 EC	     2	        movzx    edx, BYTE PTR @CatStr(_Y,0)                      ; b3    / b1
 00001C12  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 00001C19  89 45 F8	     2	        mov      DWORD PTR @CatStr(_X,1), eax                     ; a0
 00001C1C  8B 41 08	     2	        mov      eax, DWORD PTR [ecx+2*SIZEOF DWORD]              ; ecx = RK[0]
 00001C1F  8B 55 E4	     2	        mov      edx, DWORD PTR @CatStr(_Y,2)                     ; b0
 00001C22  C1 EA 18	     2	        shr      edx, 24                        
 00001C25  0F B6 D2	     2	        movzx    edx, dl
 00001C28  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 00001C2F  8B 55 E0	     2	        mov      edx, DWORD PTR @CatStr(_Y,3)                     ; b1    / b3
 00001C32  C1 EA 10	     2	        shr      edx, 16                        
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 44 - 1


 00001C35  0F B6 D2	     2	        movzx    edx, dl
 00001C38  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 00001C3F  8B 55 EC	     2	        mov      edx, DWORD PTR @CatStr(_Y,0)                     ; b2
 00001C42  C1 EA 08	     2	        shr      edx, 8
 00001C45  0F B6 D2	     2	        movzx    edx, dl
 00001C48  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 00001C4F  0F B6 55 E8	     2	        movzx    edx, BYTE PTR @CatStr(_Y,1)                      ; b3    / b1
 00001C53  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 00001C5A  89 45 F4	     2	        mov      DWORD PTR @CatStr(_X,2), eax                     ; a0
 00001C5D  8B 41 0C	     2	        mov      eax, DWORD PTR [ecx+3*SIZEOF DWORD]              ; ecx = RK[0]
 00001C60  8B 55 E0	     2	        mov      edx, DWORD PTR @CatStr(_Y,3)                     ; b0
 00001C63  C1 EA 18	     2	        shr      edx, 24                        
 00001C66  0F B6 D2	     2	        movzx    edx, dl
 00001C69  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 00001C70  8B 55 EC	     2	        mov      edx, DWORD PTR @CatStr(_Y,0)                     ; b1    / b3
 00001C73  C1 EA 10	     2	        shr      edx, 16                        
 00001C76  0F B6 D2	     2	        movzx    edx, dl
 00001C79  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 00001C80  8B 55 E8	     2	        mov      edx, DWORD PTR @CatStr(_Y,1)                     ; b2
 00001C83  C1 EA 08	     2	        shr      edx, 8
 00001C86  0F B6 D2	     2	        movzx    edx, dl
 00001C89  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 00001C90  0F B6 55 E4	     2	        movzx    edx, BYTE PTR @CatStr(_Y,2)                      ; b3    / b1
 00001C94  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 00001C9B  89 45 F0	     2	        mov      DWORD PTR @CatStr(_X,3), eax                     ; a0
 00001C9E  E9 00000103	     1	        jmp      ??0013
 00001CA3		     1	??0012:                                                       ; Decipher  
 00001CA3  8B 01	     2	        mov      eax, DWORD PTR [ecx+0*SIZEOF DWORD]              ; ecx = RK[0]
 00001CA5  8B 55 EC	     2	        mov      edx, DWORD PTR @CatStr(_Y,0)                     ; b0
 00001CA8  C1 EA 18	     2	        shr      edx, 24                        
 00001CAB  0F B6 D2	     2	        movzx    edx, dl
 00001CAE  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 00001CB5  8B 55 E0	     2	        mov      edx, DWORD PTR @CatStr(_Y,3)                     ; b1    / b3
 00001CB8  C1 EA 10	     2	        shr      edx, 16                        
 00001CBB  0F B6 D2	     2	        movzx    edx, dl
 00001CBE  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 00001CC5  8B 55 E4	     2	        mov      edx, DWORD PTR @CatStr(_Y,2)                     ; b2
 00001CC8  C1 EA 08	     2	        shr      edx, 8
 00001CCB  0F B6 D2	     2	        movzx    edx, dl
 00001CCE  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 00001CD5  0F B6 55 E8	     2	        movzx    edx, BYTE PTR @CatStr(_Y,1)                      ; b3    / b1
 00001CD9  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 00001CE0  89 45 FC	     2	        mov      DWORD PTR @CatStr(_X,0), eax                     ; a0
 00001CE3  8B 41 0C	     2	        mov      eax, DWORD PTR [ecx+3*SIZEOF DWORD]              ; ecx = RK[0]
 00001CE6  8B 55 E0	     2	        mov      edx, DWORD PTR @CatStr(_Y,3)                     ; b0
 00001CE9  C1 EA 18	     2	        shr      edx, 24                        
 00001CEC  0F B6 D2	     2	        movzx    edx, dl
 00001CEF  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 00001CF6  8B 55 E4	     2	        mov      edx, DWORD PTR @CatStr(_Y,2)                     ; b1    / b3
 00001CF9  C1 EA 10	     2	        shr      edx, 16                        
 00001CFC  0F B6 D2	     2	        movzx    edx, dl
 00001CFF  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 00001D06  8B 55 E8	     2	        mov      edx, DWORD PTR @CatStr(_Y,1)                     ; b2
 00001D09  C1 EA 08	     2	        shr      edx, 8
 00001D0C  0F B6 D2	     2	        movzx    edx, dl
 00001D0F  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 00001D16  0F B6 55 EC	     2	        movzx    edx, BYTE PTR @CatStr(_Y,0)                      ; b3    / b1
 00001D1A  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 00001D21  89 45 F0	     2	        mov      DWORD PTR @CatStr(_X,3), eax                     ; a0
 00001D24  8B 41 08	     2	        mov      eax, DWORD PTR [ecx+2*SIZEOF DWORD]              ; ecx = RK[0]
 00001D27  8B 55 E4	     2	        mov      edx, DWORD PTR @CatStr(_Y,2)                     ; b0
 00001D2A  C1 EA 18	     2	        shr      edx, 24                        
 00001D2D  0F B6 D2	     2	        movzx    edx, dl
 00001D30  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 45 - 1


 00001D37  8B 55 E8	     2	        mov      edx, DWORD PTR @CatStr(_Y,1)                     ; b1    / b3
 00001D3A  C1 EA 10	     2	        shr      edx, 16                        
 00001D3D  0F B6 D2	     2	        movzx    edx, dl
 00001D40  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 00001D47  8B 55 EC	     2	        mov      edx, DWORD PTR @CatStr(_Y,0)                     ; b2
 00001D4A  C1 EA 08	     2	        shr      edx, 8
 00001D4D  0F B6 D2	     2	        movzx    edx, dl
 00001D50  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 00001D57  0F B6 55 E0	     2	        movzx    edx, BYTE PTR @CatStr(_Y,3)                      ; b3    / b1
 00001D5B  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 00001D62  89 45 F4	     2	        mov      DWORD PTR @CatStr(_X,2), eax                     ; a0
 00001D65  8B 41 04	     2	        mov      eax, DWORD PTR [ecx+1*SIZEOF DWORD]              ; ecx = RK[0]
 00001D68  8B 55 E8	     2	        mov      edx, DWORD PTR @CatStr(_Y,1)                     ; b0
 00001D6B  C1 EA 18	     2	        shr      edx, 24                        
 00001D6E  0F B6 D2	     2	        movzx    edx, dl
 00001D71  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 00001D78  8B 55 EC	     2	        mov      edx, DWORD PTR @CatStr(_Y,0)                     ; b1    / b3
 00001D7B  C1 EA 10	     2	        shr      edx, 16                        
 00001D7E  0F B6 D2	     2	        movzx    edx, dl
 00001D81  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 00001D88  8B 55 E0	     2	        mov      edx, DWORD PTR @CatStr(_Y,3)                     ; b2
 00001D8B  C1 EA 08	     2	        shr      edx, 8
 00001D8E  0F B6 D2	     2	        movzx    edx, dl
 00001D91  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 00001D98  0F B6 55 E4	     2	        movzx    edx, BYTE PTR @CatStr(_Y,2)                      ; b3    / b1
 00001D9C  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 00001DA3  89 45 F8	     2	        mov      DWORD PTR @CatStr(_X,1), eax                     ; a0
 00001DA6		     1	??0013:
				                
				        ; 11 AES_FROUND(Y0,Y1,Y2,Y3, X0,X1,X2,X3);
				        AES_ROUND _Y, _X, 0,1,2,3       
 00001DA6  83 45 DC 10	     1	        add      DWORD PTR _RK, 4*SIZEOF DWORD          ; RK += 4; ; ecx = RK           
 00001DAA  8B 4D DC	     1	        mov      ecx, DWORD PTR _RK                                  
 00001DAD  81 3D 00000004 R  1	        cmp      DWORD PTR aesMode, _ctxStruct.drk      ; Check: ENCRYPT / DECIPHER
	   00000100
 00001DB7  0F 84 00000108    1	        je       ??0014                                       
 00001DBD  8B 01	     2	        mov      eax, DWORD PTR [ecx+0*SIZEOF DWORD]              ; ecx = RK[0]
 00001DBF  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b0
 00001DC2  C1 EA 18	     2	        shr      edx, 24                        
 00001DC5  0F B6 D2	     2	        movzx    edx, dl
 00001DC8  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 00001DCF  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b1    / b3
 00001DD2  C1 EA 10	     2	        shr      edx, 16                        
 00001DD5  0F B6 D2	     2	        movzx    edx, dl
 00001DD8  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 00001DDF  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b2
 00001DE2  C1 EA 08	     2	        shr      edx, 8
 00001DE5  0F B6 D2	     2	        movzx    edx, dl
 00001DE8  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 00001DEF  0F B6 55 F0	     2	        movzx    edx, BYTE PTR @CatStr(_X,3)                      ; b3    / b1
 00001DF3  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 00001DFA  89 45 EC	     2	        mov      DWORD PTR @CatStr(_Y,0), eax                     ; a0
 00001DFD  8B 41 04	     2	        mov      eax, DWORD PTR [ecx+1*SIZEOF DWORD]              ; ecx = RK[0]
 00001E00  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b0
 00001E03  C1 EA 18	     2	        shr      edx, 24                        
 00001E06  0F B6 D2	     2	        movzx    edx, dl
 00001E09  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 00001E10  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b1    / b3
 00001E13  C1 EA 10	     2	        shr      edx, 16                        
 00001E16  0F B6 D2	     2	        movzx    edx, dl
 00001E19  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 00001E20  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b2
 00001E23  C1 EA 08	     2	        shr      edx, 8
 00001E26  0F B6 D2	     2	        movzx    edx, dl
 00001E29  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 00001E30  0F B6 55 FC	     2	        movzx    edx, BYTE PTR @CatStr(_X,0)                      ; b3    / b1
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 46 - 1


 00001E34  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 00001E3B  89 45 E8	     2	        mov      DWORD PTR @CatStr(_Y,1), eax                     ; a0
 00001E3E  8B 41 08	     2	        mov      eax, DWORD PTR [ecx+2*SIZEOF DWORD]              ; ecx = RK[0]
 00001E41  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b0
 00001E44  C1 EA 18	     2	        shr      edx, 24                        
 00001E47  0F B6 D2	     2	        movzx    edx, dl
 00001E4A  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 00001E51  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b1    / b3
 00001E54  C1 EA 10	     2	        shr      edx, 16                        
 00001E57  0F B6 D2	     2	        movzx    edx, dl
 00001E5A  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 00001E61  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b2
 00001E64  C1 EA 08	     2	        shr      edx, 8
 00001E67  0F B6 D2	     2	        movzx    edx, dl
 00001E6A  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 00001E71  0F B6 55 F8	     2	        movzx    edx, BYTE PTR @CatStr(_X,1)                      ; b3    / b1
 00001E75  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 00001E7C  89 45 E4	     2	        mov      DWORD PTR @CatStr(_Y,2), eax                     ; a0
 00001E7F  8B 41 0C	     2	        mov      eax, DWORD PTR [ecx+3*SIZEOF DWORD]              ; ecx = RK[0]
 00001E82  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b0
 00001E85  C1 EA 18	     2	        shr      edx, 24                        
 00001E88  0F B6 D2	     2	        movzx    edx, dl
 00001E8B  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 00001E92  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b1    / b3
 00001E95  C1 EA 10	     2	        shr      edx, 16                        
 00001E98  0F B6 D2	     2	        movzx    edx, dl
 00001E9B  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 00001EA2  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b2
 00001EA5  C1 EA 08	     2	        shr      edx, 8
 00001EA8  0F B6 D2	     2	        movzx    edx, dl
 00001EAB  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 00001EB2  0F B6 55 F4	     2	        movzx    edx, BYTE PTR @CatStr(_X,2)                      ; b3    / b1
 00001EB6  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 00001EBD  89 45 E0	     2	        mov      DWORD PTR @CatStr(_Y,3), eax                     ; a0
 00001EC0  E9 00000103	     1	        jmp      ??0015
 00001EC5		     1	??0014:                                                       ; Decipher  
 00001EC5  8B 01	     2	        mov      eax, DWORD PTR [ecx+0*SIZEOF DWORD]              ; ecx = RK[0]
 00001EC7  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b0
 00001ECA  C1 EA 18	     2	        shr      edx, 24                        
 00001ECD  0F B6 D2	     2	        movzx    edx, dl
 00001ED0  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 00001ED7  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b1    / b3
 00001EDA  C1 EA 10	     2	        shr      edx, 16                        
 00001EDD  0F B6 D2	     2	        movzx    edx, dl
 00001EE0  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 00001EE7  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b2
 00001EEA  C1 EA 08	     2	        shr      edx, 8
 00001EED  0F B6 D2	     2	        movzx    edx, dl
 00001EF0  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 00001EF7  0F B6 55 F8	     2	        movzx    edx, BYTE PTR @CatStr(_X,1)                      ; b3    / b1
 00001EFB  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 00001F02  89 45 EC	     2	        mov      DWORD PTR @CatStr(_Y,0), eax                     ; a0
 00001F05  8B 41 0C	     2	        mov      eax, DWORD PTR [ecx+3*SIZEOF DWORD]              ; ecx = RK[0]
 00001F08  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b0
 00001F0B  C1 EA 18	     2	        shr      edx, 24                        
 00001F0E  0F B6 D2	     2	        movzx    edx, dl
 00001F11  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 00001F18  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b1    / b3
 00001F1B  C1 EA 10	     2	        shr      edx, 16                        
 00001F1E  0F B6 D2	     2	        movzx    edx, dl
 00001F21  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 00001F28  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b2
 00001F2B  C1 EA 08	     2	        shr      edx, 8
 00001F2E  0F B6 D2	     2	        movzx    edx, dl
 00001F31  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 47 - 1


	   00002A0C R
 00001F38  0F B6 55 FC	     2	        movzx    edx, BYTE PTR @CatStr(_X,0)                      ; b3    / b1
 00001F3C  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 00001F43  89 45 E0	     2	        mov      DWORD PTR @CatStr(_Y,3), eax                     ; a0
 00001F46  8B 41 08	     2	        mov      eax, DWORD PTR [ecx+2*SIZEOF DWORD]              ; ecx = RK[0]
 00001F49  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b0
 00001F4C  C1 EA 18	     2	        shr      edx, 24                        
 00001F4F  0F B6 D2	     2	        movzx    edx, dl
 00001F52  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 00001F59  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b1    / b3
 00001F5C  C1 EA 10	     2	        shr      edx, 16                        
 00001F5F  0F B6 D2	     2	        movzx    edx, dl
 00001F62  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 00001F69  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b2
 00001F6C  C1 EA 08	     2	        shr      edx, 8
 00001F6F  0F B6 D2	     2	        movzx    edx, dl
 00001F72  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 00001F79  0F B6 55 F0	     2	        movzx    edx, BYTE PTR @CatStr(_X,3)                      ; b3    / b1
 00001F7D  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 00001F84  89 45 E4	     2	        mov      DWORD PTR @CatStr(_Y,2), eax                     ; a0
 00001F87  8B 41 04	     2	        mov      eax, DWORD PTR [ecx+1*SIZEOF DWORD]              ; ecx = RK[0]
 00001F8A  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b0
 00001F8D  C1 EA 18	     2	        shr      edx, 24                        
 00001F90  0F B6 D2	     2	        movzx    edx, dl
 00001F93  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 00001F9A  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b1    / b3
 00001F9D  C1 EA 10	     2	        shr      edx, 16                        
 00001FA0  0F B6 D2	     2	        movzx    edx, dl
 00001FA3  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 00001FAA  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b2
 00001FAD  C1 EA 08	     2	        shr      edx, 8
 00001FB0  0F B6 D2	     2	        movzx    edx, dl
 00001FB3  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 00001FBA  0F B6 55 F4	     2	        movzx    edx, BYTE PTR @CatStr(_X,2)                      ; b3    / b1
 00001FBE  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 00001FC5  89 45 E8	     2	        mov      DWORD PTR @CatStr(_Y,1), eax                     ; a0
 00001FC8		     1	??0015:

 00001FC8  8B 55 08		        mov      edx, DWORD PTR _ctx                    ; if( ctx->nr == 12 )
 00001FCB  83 BA 00000200	        cmp      DWORD PTR [edx]._ctxStruct.rnr, 12     ; 192bit-key?   
	   0C
 00001FD2  0F 84 00000444	        je       @F                                     ; Last round = 12th Round.

				        ; 12 AES_FROUND(X0,X1,X2,X3, Y0,Y1,Y2,Y3);      ; ctx->nr == 14
				        AES_ROUND _X, _Y, 0,1,2,3                       ; 256bit-key?   
 00001FD8  83 45 DC 10	     1	        add      DWORD PTR _RK, 4*SIZEOF DWORD          ; RK += 4; ; ecx = RK           
 00001FDC  8B 4D DC	     1	        mov      ecx, DWORD PTR _RK                                  
 00001FDF  81 3D 00000004 R  1	        cmp      DWORD PTR aesMode, _ctxStruct.drk      ; Check: ENCRYPT / DECIPHER
	   00000100
 00001FE9  0F 84 00000108    1	        je       ??0016                                       
 00001FEF  8B 01	     2	        mov      eax, DWORD PTR [ecx+0*SIZEOF DWORD]              ; ecx = RK[0]
 00001FF1  8B 55 EC	     2	        mov      edx, DWORD PTR @CatStr(_Y,0)                     ; b0
 00001FF4  C1 EA 18	     2	        shr      edx, 24                        
 00001FF7  0F B6 D2	     2	        movzx    edx, dl
 00001FFA  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 00002001  8B 55 E8	     2	        mov      edx, DWORD PTR @CatStr(_Y,1)                     ; b1    / b3
 00002004  C1 EA 10	     2	        shr      edx, 16                        
 00002007  0F B6 D2	     2	        movzx    edx, dl
 0000200A  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 00002011  8B 55 E4	     2	        mov      edx, DWORD PTR @CatStr(_Y,2)                     ; b2
 00002014  C1 EA 08	     2	        shr      edx, 8
 00002017  0F B6 D2	     2	        movzx    edx, dl
 0000201A  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 00002021  0F B6 55 E0	     2	        movzx    edx, BYTE PTR @CatStr(_Y,3)                      ; b3    / b1
 00002025  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 0000202C  89 45 FC	     2	        mov      DWORD PTR @CatStr(_X,0), eax                     ; a0
 0000202F  8B 41 04	     2	        mov      eax, DWORD PTR [ecx+1*SIZEOF DWORD]              ; ecx = RK[0]
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 48 - 1


 00002032  8B 55 E8	     2	        mov      edx, DWORD PTR @CatStr(_Y,1)                     ; b0
 00002035  C1 EA 18	     2	        shr      edx, 24                        
 00002038  0F B6 D2	     2	        movzx    edx, dl
 0000203B  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 00002042  8B 55 E4	     2	        mov      edx, DWORD PTR @CatStr(_Y,2)                     ; b1    / b3
 00002045  C1 EA 10	     2	        shr      edx, 16                        
 00002048  0F B6 D2	     2	        movzx    edx, dl
 0000204B  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 00002052  8B 55 E0	     2	        mov      edx, DWORD PTR @CatStr(_Y,3)                     ; b2
 00002055  C1 EA 08	     2	        shr      edx, 8
 00002058  0F B6 D2	     2	        movzx    edx, dl
 0000205B  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 00002062  0F B6 55 EC	     2	        movzx    edx, BYTE PTR @CatStr(_Y,0)                      ; b3    / b1
 00002066  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 0000206D  89 45 F8	     2	        mov      DWORD PTR @CatStr(_X,1), eax                     ; a0
 00002070  8B 41 08	     2	        mov      eax, DWORD PTR [ecx+2*SIZEOF DWORD]              ; ecx = RK[0]
 00002073  8B 55 E4	     2	        mov      edx, DWORD PTR @CatStr(_Y,2)                     ; b0
 00002076  C1 EA 18	     2	        shr      edx, 24                        
 00002079  0F B6 D2	     2	        movzx    edx, dl
 0000207C  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 00002083  8B 55 E0	     2	        mov      edx, DWORD PTR @CatStr(_Y,3)                     ; b1    / b3
 00002086  C1 EA 10	     2	        shr      edx, 16                        
 00002089  0F B6 D2	     2	        movzx    edx, dl
 0000208C  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 00002093  8B 55 EC	     2	        mov      edx, DWORD PTR @CatStr(_Y,0)                     ; b2
 00002096  C1 EA 08	     2	        shr      edx, 8
 00002099  0F B6 D2	     2	        movzx    edx, dl
 0000209C  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 000020A3  0F B6 55 E8	     2	        movzx    edx, BYTE PTR @CatStr(_Y,1)                      ; b3    / b1
 000020A7  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 000020AE  89 45 F4	     2	        mov      DWORD PTR @CatStr(_X,2), eax                     ; a0
 000020B1  8B 41 0C	     2	        mov      eax, DWORD PTR [ecx+3*SIZEOF DWORD]              ; ecx = RK[0]
 000020B4  8B 55 E0	     2	        mov      edx, DWORD PTR @CatStr(_Y,3)                     ; b0
 000020B7  C1 EA 18	     2	        shr      edx, 24                        
 000020BA  0F B6 D2	     2	        movzx    edx, dl
 000020BD  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 000020C4  8B 55 EC	     2	        mov      edx, DWORD PTR @CatStr(_Y,0)                     ; b1    / b3
 000020C7  C1 EA 10	     2	        shr      edx, 16                        
 000020CA  0F B6 D2	     2	        movzx    edx, dl
 000020CD  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 000020D4  8B 55 E8	     2	        mov      edx, DWORD PTR @CatStr(_Y,1)                     ; b2
 000020D7  C1 EA 08	     2	        shr      edx, 8
 000020DA  0F B6 D2	     2	        movzx    edx, dl
 000020DD  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 000020E4  0F B6 55 E4	     2	        movzx    edx, BYTE PTR @CatStr(_Y,2)                      ; b3    / b1
 000020E8  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 000020EF  89 45 F0	     2	        mov      DWORD PTR @CatStr(_X,3), eax                     ; a0
 000020F2  E9 00000103	     1	        jmp      ??0017
 000020F7		     1	??0016:                                                       ; Decipher  
 000020F7  8B 01	     2	        mov      eax, DWORD PTR [ecx+0*SIZEOF DWORD]              ; ecx = RK[0]
 000020F9  8B 55 EC	     2	        mov      edx, DWORD PTR @CatStr(_Y,0)                     ; b0
 000020FC  C1 EA 18	     2	        shr      edx, 24                        
 000020FF  0F B6 D2	     2	        movzx    edx, dl
 00002102  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 00002109  8B 55 E0	     2	        mov      edx, DWORD PTR @CatStr(_Y,3)                     ; b1    / b3
 0000210C  C1 EA 10	     2	        shr      edx, 16                        
 0000210F  0F B6 D2	     2	        movzx    edx, dl
 00002112  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 00002119  8B 55 E4	     2	        mov      edx, DWORD PTR @CatStr(_Y,2)                     ; b2
 0000211C  C1 EA 08	     2	        shr      edx, 8
 0000211F  0F B6 D2	     2	        movzx    edx, dl
 00002122  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 00002129  0F B6 55 E8	     2	        movzx    edx, BYTE PTR @CatStr(_Y,1)                      ; b3    / b1
 0000212D  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 49 - 1


 00002134  89 45 FC	     2	        mov      DWORD PTR @CatStr(_X,0), eax                     ; a0
 00002137  8B 41 0C	     2	        mov      eax, DWORD PTR [ecx+3*SIZEOF DWORD]              ; ecx = RK[0]
 0000213A  8B 55 E0	     2	        mov      edx, DWORD PTR @CatStr(_Y,3)                     ; b0
 0000213D  C1 EA 18	     2	        shr      edx, 24                        
 00002140  0F B6 D2	     2	        movzx    edx, dl
 00002143  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 0000214A  8B 55 E4	     2	        mov      edx, DWORD PTR @CatStr(_Y,2)                     ; b1    / b3
 0000214D  C1 EA 10	     2	        shr      edx, 16                        
 00002150  0F B6 D2	     2	        movzx    edx, dl
 00002153  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 0000215A  8B 55 E8	     2	        mov      edx, DWORD PTR @CatStr(_Y,1)                     ; b2
 0000215D  C1 EA 08	     2	        shr      edx, 8
 00002160  0F B6 D2	     2	        movzx    edx, dl
 00002163  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 0000216A  0F B6 55 EC	     2	        movzx    edx, BYTE PTR @CatStr(_Y,0)                      ; b3    / b1
 0000216E  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 00002175  89 45 F0	     2	        mov      DWORD PTR @CatStr(_X,3), eax                     ; a0
 00002178  8B 41 08	     2	        mov      eax, DWORD PTR [ecx+2*SIZEOF DWORD]              ; ecx = RK[0]
 0000217B  8B 55 E4	     2	        mov      edx, DWORD PTR @CatStr(_Y,2)                     ; b0
 0000217E  C1 EA 18	     2	        shr      edx, 24                        
 00002181  0F B6 D2	     2	        movzx    edx, dl
 00002184  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 0000218B  8B 55 E8	     2	        mov      edx, DWORD PTR @CatStr(_Y,1)                     ; b1    / b3
 0000218E  C1 EA 10	     2	        shr      edx, 16                        
 00002191  0F B6 D2	     2	        movzx    edx, dl
 00002194  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 0000219B  8B 55 EC	     2	        mov      edx, DWORD PTR @CatStr(_Y,0)                     ; b2
 0000219E  C1 EA 08	     2	        shr      edx, 8
 000021A1  0F B6 D2	     2	        movzx    edx, dl
 000021A4  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 000021AB  0F B6 55 E0	     2	        movzx    edx, BYTE PTR @CatStr(_Y,3)                      ; b3    / b1
 000021AF  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 000021B6  89 45 F4	     2	        mov      DWORD PTR @CatStr(_X,2), eax                     ; a0
 000021B9  8B 41 04	     2	        mov      eax, DWORD PTR [ecx+1*SIZEOF DWORD]              ; ecx = RK[0]
 000021BC  8B 55 E8	     2	        mov      edx, DWORD PTR @CatStr(_Y,1)                     ; b0
 000021BF  C1 EA 18	     2	        shr      edx, 24                        
 000021C2  0F B6 D2	     2	        movzx    edx, dl
 000021C5  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 000021CC  8B 55 EC	     2	        mov      edx, DWORD PTR @CatStr(_Y,0)                     ; b1    / b3
 000021CF  C1 EA 10	     2	        shr      edx, 16                        
 000021D2  0F B6 D2	     2	        movzx    edx, dl
 000021D5  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 000021DC  8B 55 E0	     2	        mov      edx, DWORD PTR @CatStr(_Y,3)                     ; b2
 000021DF  C1 EA 08	     2	        shr      edx, 8
 000021E2  0F B6 D2	     2	        movzx    edx, dl
 000021E5  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 000021EC  0F B6 55 E4	     2	        movzx    edx, BYTE PTR @CatStr(_Y,2)                      ; b3    / b1
 000021F0  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 000021F7  89 45 F8	     2	        mov      DWORD PTR @CatStr(_X,1), eax                     ; a0
 000021FA		     1	??0017:
				                                                        ; Last round = 14th Round.
				        ; 13 AES_FROUND(Y0,Y1,Y2,Y3, X0,X1,X2,X3);
				        AES_ROUND _Y, _X, 0,1,2,3       
 000021FA  83 45 DC 10	     1	        add      DWORD PTR _RK, 4*SIZEOF DWORD          ; RK += 4; ; ecx = RK           
 000021FE  8B 4D DC	     1	        mov      ecx, DWORD PTR _RK                                  
 00002201  81 3D 00000004 R  1	        cmp      DWORD PTR aesMode, _ctxStruct.drk      ; Check: ENCRYPT / DECIPHER
	   00000100
 0000220B  0F 84 00000108    1	        je       ??0018                                       
 00002211  8B 01	     2	        mov      eax, DWORD PTR [ecx+0*SIZEOF DWORD]              ; ecx = RK[0]
 00002213  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b0
 00002216  C1 EA 18	     2	        shr      edx, 24                        
 00002219  0F B6 D2	     2	        movzx    edx, dl
 0000221C  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 00002223  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b1    / b3
 00002226  C1 EA 10	     2	        shr      edx, 16                        
 00002229  0F B6 D2	     2	        movzx    edx, dl
 0000222C  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 50 - 1


	   00001A0C R
 00002233  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b2
 00002236  C1 EA 08	     2	        shr      edx, 8
 00002239  0F B6 D2	     2	        movzx    edx, dl
 0000223C  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 00002243  0F B6 55 F0	     2	        movzx    edx, BYTE PTR @CatStr(_X,3)                      ; b3    / b1
 00002247  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 0000224E  89 45 EC	     2	        mov      DWORD PTR @CatStr(_Y,0), eax                     ; a0
 00002251  8B 41 04	     2	        mov      eax, DWORD PTR [ecx+1*SIZEOF DWORD]              ; ecx = RK[0]
 00002254  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b0
 00002257  C1 EA 18	     2	        shr      edx, 24                        
 0000225A  0F B6 D2	     2	        movzx    edx, dl
 0000225D  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 00002264  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b1    / b3
 00002267  C1 EA 10	     2	        shr      edx, 16                        
 0000226A  0F B6 D2	     2	        movzx    edx, dl
 0000226D  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 00002274  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b2
 00002277  C1 EA 08	     2	        shr      edx, 8
 0000227A  0F B6 D2	     2	        movzx    edx, dl
 0000227D  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 00002284  0F B6 55 FC	     2	        movzx    edx, BYTE PTR @CatStr(_X,0)                      ; b3    / b1
 00002288  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 0000228F  89 45 E8	     2	        mov      DWORD PTR @CatStr(_Y,1), eax                     ; a0
 00002292  8B 41 08	     2	        mov      eax, DWORD PTR [ecx+2*SIZEOF DWORD]              ; ecx = RK[0]
 00002295  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b0
 00002298  C1 EA 18	     2	        shr      edx, 24                        
 0000229B  0F B6 D2	     2	        movzx    edx, dl
 0000229E  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 000022A5  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b1    / b3
 000022A8  C1 EA 10	     2	        shr      edx, 16                        
 000022AB  0F B6 D2	     2	        movzx    edx, dl
 000022AE  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 000022B5  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b2
 000022B8  C1 EA 08	     2	        shr      edx, 8
 000022BB  0F B6 D2	     2	        movzx    edx, dl
 000022BE  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 000022C5  0F B6 55 F8	     2	        movzx    edx, BYTE PTR @CatStr(_X,1)                      ; b3    / b1
 000022C9  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 000022D0  89 45 E4	     2	        mov      DWORD PTR @CatStr(_Y,2), eax                     ; a0
 000022D3  8B 41 0C	     2	        mov      eax, DWORD PTR [ecx+3*SIZEOF DWORD]              ; ecx = RK[0]
 000022D6  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b0
 000022D9  C1 EA 18	     2	        shr      edx, 24                        
 000022DC  0F B6 D2	     2	        movzx    edx, dl
 000022DF  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   00001E0C R
 000022E6  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b1    / b3
 000022E9  C1 EA 10	     2	        shr      edx, 16                        
 000022EC  0F B6 D2	     2	        movzx    edx, dl
 000022EF  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   00001A0C R
 000022F6  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b2
 000022F9  C1 EA 08	     2	        shr      edx, 8
 000022FC  0F B6 D2	     2	        movzx    edx, dl
 000022FF  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   0000160C R
 00002306  0F B6 55 F4	     2	        movzx    edx, BYTE PTR @CatStr(_X,2)                      ; b3    / b1
 0000230A  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_FT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   0000120C R
 00002311  89 45 E0	     2	        mov      DWORD PTR @CatStr(_Y,3), eax                     ; a0
 00002314  E9 00000103	     1	        jmp      ??0019
 00002319		     1	??0018:                                                       ; Decipher  
 00002319  8B 01	     2	        mov      eax, DWORD PTR [ecx+0*SIZEOF DWORD]              ; ecx = RK[0]
 0000231B  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b0
 0000231E  C1 EA 18	     2	        shr      edx, 24                        
 00002321  0F B6 D2	     2	        movzx    edx, dl
 00002324  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 0000232B  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b1    / b3
 0000232E  C1 EA 10	     2	        shr      edx, 16                        
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 51 - 1


 00002331  0F B6 D2	     2	        movzx    edx, dl
 00002334  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 0000233B  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b2
 0000233E  C1 EA 08	     2	        shr      edx, 8
 00002341  0F B6 D2	     2	        movzx    edx, dl
 00002344  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 0000234B  0F B6 55 F8	     2	        movzx    edx, BYTE PTR @CatStr(_X,1)                      ; b3    / b1
 0000234F  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 00002356  89 45 EC	     2	        mov      DWORD PTR @CatStr(_Y,0), eax                     ; a0
 00002359  8B 41 0C	     2	        mov      eax, DWORD PTR [ecx+3*SIZEOF DWORD]              ; ecx = RK[0]
 0000235C  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b0
 0000235F  C1 EA 18	     2	        shr      edx, 24                        
 00002362  0F B6 D2	     2	        movzx    edx, dl
 00002365  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 0000236C  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b1    / b3
 0000236F  C1 EA 10	     2	        shr      edx, 16                        
 00002372  0F B6 D2	     2	        movzx    edx, dl
 00002375  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 0000237C  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b2
 0000237F  C1 EA 08	     2	        shr      edx, 8
 00002382  0F B6 D2	     2	        movzx    edx, dl
 00002385  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 0000238C  0F B6 55 FC	     2	        movzx    edx, BYTE PTR @CatStr(_X,0)                      ; b3    / b1
 00002390  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 00002397  89 45 E0	     2	        mov      DWORD PTR @CatStr(_Y,3), eax                     ; a0
 0000239A  8B 41 08	     2	        mov      eax, DWORD PTR [ecx+2*SIZEOF DWORD]              ; ecx = RK[0]
 0000239D  8B 55 F4	     2	        mov      edx, DWORD PTR @CatStr(_X,2)                     ; b0
 000023A0  C1 EA 18	     2	        shr      edx, 24                        
 000023A3  0F B6 D2	     2	        movzx    edx, dl
 000023A6  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 000023AD  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b1    / b3
 000023B0  C1 EA 10	     2	        shr      edx, 16                        
 000023B3  0F B6 D2	     2	        movzx    edx, dl
 000023B6  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 000023BD  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b2
 000023C0  C1 EA 08	     2	        shr      edx, 8
 000023C3  0F B6 D2	     2	        movzx    edx, dl
 000023C6  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 000023CD  0F B6 55 F0	     2	        movzx    edx, BYTE PTR @CatStr(_X,3)                      ; b3    / b1
 000023D1  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 000023D8  89 45 E4	     2	        mov      DWORD PTR @CatStr(_Y,2), eax                     ; a0
 000023DB  8B 41 04	     2	        mov      eax, DWORD PTR [ecx+1*SIZEOF DWORD]              ; ecx = RK[0]
 000023DE  8B 55 F8	     2	        mov      edx, DWORD PTR @CatStr(_X,1)                     ; b0
 000023E1  C1 EA 18	     2	        shr      edx, 24                        
 000023E4  0F B6 D2	     2	        movzx    edx, dl
 000023E7  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,0)[edx*SIZEOF DWORD]   ; FT[0] / RT[0]
	   0000220C R
 000023EE  8B 55 FC	     2	        mov      edx, DWORD PTR @CatStr(_X,0)                     ; b1    / b3
 000023F1  C1 EA 10	     2	        shr      edx, 16                        
 000023F4  0F B6 D2	     2	        movzx    edx, dl
 000023F7  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,1)[edx*SIZEOF DWORD]   ; FT[1] / RT[1]
	   0000260C R
 000023FE  8B 55 F0	     2	        mov      edx, DWORD PTR @CatStr(_X,3)                     ; b2
 00002401  C1 EA 08	     2	        shr      edx, 8
 00002404  0F B6 D2	     2	        movzx    edx, dl
 00002407  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,2)[edx*SIZEOF DWORD]   ; FT[2] / RT[2]
	   00002A0C R
 0000240E  0F B6 55 F4	     2	        movzx    edx, BYTE PTR @CatStr(_X,2)                      ; b3    / b1
 00002412  33 04 95	     2	        xor      eax, DWORD PTR @CatStr(_RT,3)[edx*SIZEOF DWORD]   ; FT[3] / RT[3]
	   00002E0C R
 00002419  89 45 E8	     2	        mov      DWORD PTR @CatStr(_Y,1), eax                     ; a0
 0000241C		     1	??0019:
				        
 0000241C			@@:     ; #define AES_LAST_ROUND Fsb(X0,X1,X2,X3,Y0,Y1,Y2,Y3)           \
				        ; {                                                             \
				        ;     RK += 4;                                                  \
				        ;                                                               \
				        ;     X0 = RK[0] ^ ( FSb[ (uint8) ( Y0 >> 24 ) ] << 24 ) ^      \
				        ;                  ( FSb[ (uint8) ( Y1 >> 16 ) ] << 16 ) ^      \
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 52 - 1


				        ;                  ( FSb[ (uint8) ( Y2 >>  8 ) ] <<  8 ) ^      \
				        ;                  ( FSb[ (uint8) ( Y3       ) ]       );       \
				        ;                                                               \
				        ;     X1 = RK[1] ^ ( FSb[ (uint8) ( Y1 >> 24 ) ] << 24 ) ^      \
				        ;                  ( FSb[ (uint8) ( Y2 >> 16 ) ] << 16 ) ^      \
				        ;                  ( FSb[ (uint8) ( Y3 >>  8 ) ] <<  8 ) ^      \
				        ;                  ( FSb[ (uint8) ( Y0       ) ]       );       \
				        ;                                                               \
				        ;     X2 = RK[2] ^ ( FSb[ (uint8) ( Y2 >> 24 ) ] << 24 ) ^      \
				        ;                  ( FSb[ (uint8) ( Y3 >> 16 ) ] << 16 ) ^      \
				        ;                  ( FSb[ (uint8) ( Y0 >>  8 ) ] <<  8 ) ^      \
				        ;                  ( FSb[ (uint8) ( Y1       ) ]       );       \
				        ;                                                               \
				        ;     X3 = RK[3] ^ ( FSb[ (uint8) ( Y3 >> 24 ) ] << 24 ) ^      \
				        ;                  ( FSb[ (uint8) ( Y0 >> 16 ) ] << 16 ) ^      \
				        ;                  ( FSb[ (uint8) ( Y1 >>  8 ) ] <<  8 ) ^      \
				        ;                  ( FSb[ (uint8) ( Y2       ) ]       );       \
				        ; )

				        ; 10th/12th/14th Final Round
				        AES_LAST_ROUND _X, _Y, 0,1,2,3
 0000241C  8B 4D DC	     1	        mov      ecx, DWORD PTR _RK                             ; RK += 4; ; ecx = RK   
 0000241F  83 C1 10	     1	        add      ecx, 4*SIZEOF DWORD                                                    
 00002422  81 3D 00000004 R  1	        cmp      DWORD PTR aesMode, _ctxStruct.drk              ; Check: ENCRYPT / DECIPHER
	   00000100
 0000242C  0F 84 0000014C    1	        je       ??001A                                      
 00002432  8B 01	     2	        mov      eax, DWORD PTR [ecx+0*SIZEOF DWORD]  ; RK[0]
 00002434  8B 55 EC	     2	        mov      edx, DWORD PTR  @CatStr(_Y,0)        ; _b0
 00002437  C1 EA 18	     2	        shr      edx, 24                        
 0000243A  0F B6 D2	     2	        movzx    edx, dl
 0000243D  0F B6 92	     2	        movzx    edx, BYTE PTR _Fsb[edx]               ; Fsb / RSb[(uint8)(Y0 >> 24)]
	   0000320C R
 00002444  C1 E2 18	     2	        shl      edx, 24                        
 00002447  33 C2	     2	        xor      eax, edx
 00002449  8B 55 E8	     2	        mov      edx, DWORD PTR @CatStr(_Y,1)         ; _b1
 0000244C  C1 EA 10	     2	        shr      edx, 16                        
 0000244F  0F B6 D2	     2	        movzx    edx, dl
 00002452  0F B6 92	     2	        movzx    edx, BYTE PTR _Fsb[edx]
	   0000320C R
 00002459  C1 E2 10	     2	        shl      edx, 16                        
 0000245C  33 C2	     2	        xor      eax, edx
 0000245E  8B 55 E4	     2	        mov      edx, DWORD PTR @CatStr(_Y,2)         ; _b2
 00002461  C1 EA 08	     2	        shr      edx, 8
 00002464  0F B6 D2	     2	        movzx    edx, dl
 00002467  0F B6 92	     2	        movzx    edx, BYTE PTR _Fsb[edx]
	   0000320C R
 0000246E  C1 E2 08	     2	        shl      edx, 8
 00002471  33 C2	     2	        xor      eax, edx
 00002473  0F B6 55 E0	     2	        movzx    edx, BYTE PTR @CatStr(_Y,3)          ; _b3
 00002477  0F B6 92	     2	        movzx    edx, BYTE PTR _Fsb[edx]
	   0000320C R
 0000247E  33 C2	     2	        xor      eax, edx
 00002480  89 45 FC	     2	        mov      DWORD PTR @CatStr(_X,0), eax         ; _a0
 00002483  8B 41 04	     2	        mov      eax, DWORD PTR [ecx+1*SIZEOF DWORD]  ; RK[0]
 00002486  8B 55 E8	     2	        mov      edx, DWORD PTR  @CatStr(_Y,1)        ; _b0
 00002489  C1 EA 18	     2	        shr      edx, 24                        
 0000248C  0F B6 D2	     2	        movzx    edx, dl
 0000248F  0F B6 92	     2	        movzx    edx, BYTE PTR _Fsb[edx]               ; Fsb / RSb[(uint8)(Y0 >> 24)]
	   0000320C R
 00002496  C1 E2 18	     2	        shl      edx, 24                        
 00002499  33 C2	     2	        xor      eax, edx
 0000249B  8B 55 E4	     2	        mov      edx, DWORD PTR @CatStr(_Y,2)         ; _b1
 0000249E  C1 EA 10	     2	        shr      edx, 16                        
 000024A1  0F B6 D2	     2	        movzx    edx, dl
 000024A4  0F B6 92	     2	        movzx    edx, BYTE PTR _Fsb[edx]
	   0000320C R
 000024AB  C1 E2 10	     2	        shl      edx, 16                        
 000024AE  33 C2	     2	        xor      eax, edx
 000024B0  8B 55 E0	     2	        mov      edx, DWORD PTR @CatStr(_Y,3)         ; _b2
 000024B3  C1 EA 08	     2	        shr      edx, 8
 000024B6  0F B6 D2	     2	        movzx    edx, dl
 000024B9  0F B6 92	     2	        movzx    edx, BYTE PTR _Fsb[edx]
	   0000320C R
 000024C0  C1 E2 08	     2	        shl      edx, 8
 000024C3  33 C2	     2	        xor      eax, edx
 000024C5  0F B6 55 EC	     2	        movzx    edx, BYTE PTR @CatStr(_Y,0)          ; _b3
 000024C9  0F B6 92	     2	        movzx    edx, BYTE PTR _Fsb[edx]
	   0000320C R
 000024D0  33 C2	     2	        xor      eax, edx
 000024D2  89 45 F8	     2	        mov      DWORD PTR @CatStr(_X,1), eax         ; _a0
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 53 - 1


 000024D5  8B 41 08	     2	        mov      eax, DWORD PTR [ecx+2*SIZEOF DWORD]  ; RK[0]
 000024D8  8B 55 E4	     2	        mov      edx, DWORD PTR  @CatStr(_Y,2)        ; _b0
 000024DB  C1 EA 18	     2	        shr      edx, 24                        
 000024DE  0F B6 D2	     2	        movzx    edx, dl
 000024E1  0F B6 92	     2	        movzx    edx, BYTE PTR _Fsb[edx]               ; Fsb / RSb[(uint8)(Y0 >> 24)]
	   0000320C R
 000024E8  C1 E2 18	     2	        shl      edx, 24                        
 000024EB  33 C2	     2	        xor      eax, edx
 000024ED  8B 55 E0	     2	        mov      edx, DWORD PTR @CatStr(_Y,3)         ; _b1
 000024F0  C1 EA 10	     2	        shr      edx, 16                        
 000024F3  0F B6 D2	     2	        movzx    edx, dl
 000024F6  0F B6 92	     2	        movzx    edx, BYTE PTR _Fsb[edx]
	   0000320C R
 000024FD  C1 E2 10	     2	        shl      edx, 16                        
 00002500  33 C2	     2	        xor      eax, edx
 00002502  8B 55 EC	     2	        mov      edx, DWORD PTR @CatStr(_Y,0)         ; _b2
 00002505  C1 EA 08	     2	        shr      edx, 8
 00002508  0F B6 D2	     2	        movzx    edx, dl
 0000250B  0F B6 92	     2	        movzx    edx, BYTE PTR _Fsb[edx]
	   0000320C R
 00002512  C1 E2 08	     2	        shl      edx, 8
 00002515  33 C2	     2	        xor      eax, edx
 00002517  0F B6 55 E8	     2	        movzx    edx, BYTE PTR @CatStr(_Y,1)          ; _b3
 0000251B  0F B6 92	     2	        movzx    edx, BYTE PTR _Fsb[edx]
	   0000320C R
 00002522  33 C2	     2	        xor      eax, edx
 00002524  89 45 F4	     2	        mov      DWORD PTR @CatStr(_X,2), eax         ; _a0
 00002527  8B 41 0C	     2	        mov      eax, DWORD PTR [ecx+3*SIZEOF DWORD]  ; RK[0]
 0000252A  8B 55 E0	     2	        mov      edx, DWORD PTR  @CatStr(_Y,3)        ; _b0
 0000252D  C1 EA 18	     2	        shr      edx, 24                        
 00002530  0F B6 D2	     2	        movzx    edx, dl
 00002533  0F B6 92	     2	        movzx    edx, BYTE PTR _Fsb[edx]               ; Fsb / RSb[(uint8)(Y0 >> 24)]
	   0000320C R
 0000253A  C1 E2 18	     2	        shl      edx, 24                        
 0000253D  33 C2	     2	        xor      eax, edx
 0000253F  8B 55 EC	     2	        mov      edx, DWORD PTR @CatStr(_Y,0)         ; _b1
 00002542  C1 EA 10	     2	        shr      edx, 16                        
 00002545  0F B6 D2	     2	        movzx    edx, dl
 00002548  0F B6 92	     2	        movzx    edx, BYTE PTR _Fsb[edx]
	   0000320C R
 0000254F  C1 E2 10	     2	        shl      edx, 16                        
 00002552  33 C2	     2	        xor      eax, edx
 00002554  8B 55 E8	     2	        mov      edx, DWORD PTR @CatStr(_Y,1)         ; _b2
 00002557  C1 EA 08	     2	        shr      edx, 8
 0000255A  0F B6 D2	     2	        movzx    edx, dl
 0000255D  0F B6 92	     2	        movzx    edx, BYTE PTR _Fsb[edx]
	   0000320C R
 00002564  C1 E2 08	     2	        shl      edx, 8
 00002567  33 C2	     2	        xor      eax, edx
 00002569  0F B6 55 E4	     2	        movzx    edx, BYTE PTR @CatStr(_Y,2)          ; _b3
 0000256D  0F B6 92	     2	        movzx    edx, BYTE PTR _Fsb[edx]
	   0000320C R
 00002574  33 C2	     2	        xor      eax, edx
 00002576  89 45 F0	     2	        mov      DWORD PTR @CatStr(_X,3), eax         ; _a0
 00002579  E9 00000147	     1	        jmp      ??001B                                                              
 0000257E		     1	??001A:                                                      ; Encrypt   ; Decipher
 0000257E  8B 01	     2	        mov      eax, DWORD PTR [ecx+0*SIZEOF DWORD]  ; RK[0]
 00002580  8B 55 EC	     2	        mov      edx, DWORD PTR  @CatStr(_Y,0)        ; _b0
 00002583  C1 EA 18	     2	        shr      edx, 24                        
 00002586  0F B6 D2	     2	        movzx    edx, dl
 00002589  0F B6 92	     2	        movzx    edx, BYTE PTR _Rsb[edx]               ; Fsb / RSb[(uint8)(Y0 >> 24)]
	   0000330C R
 00002590  C1 E2 18	     2	        shl      edx, 24                        
 00002593  33 C2	     2	        xor      eax, edx
 00002595  8B 55 E0	     2	        mov      edx, DWORD PTR @CatStr(_Y,3)         ; _b1
 00002598  C1 EA 10	     2	        shr      edx, 16                        
 0000259B  0F B6 D2	     2	        movzx    edx, dl
 0000259E  0F B6 92	     2	        movzx    edx, BYTE PTR _Rsb[edx]
	   0000330C R
 000025A5  C1 E2 10	     2	        shl      edx, 16                        
 000025A8  33 C2	     2	        xor      eax, edx
 000025AA  8B 55 E4	     2	        mov      edx, DWORD PTR @CatStr(_Y,2)         ; _b2
 000025AD  C1 EA 08	     2	        shr      edx, 8
 000025B0  0F B6 D2	     2	        movzx    edx, dl
 000025B3  0F B6 92	     2	        movzx    edx, BYTE PTR _Rsb[edx]
	   0000330C R
 000025BA  C1 E2 08	     2	        shl      edx, 8
 000025BD  33 C2	     2	        xor      eax, edx
 000025BF  0F B6 55 E8	     2	        movzx    edx, BYTE PTR @CatStr(_Y,1)          ; _b3
 000025C3  0F B6 92	     2	        movzx    edx, BYTE PTR _Rsb[edx]
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 54 - 1


	   0000330C R
 000025CA  33 C2	     2	        xor      eax, edx
 000025CC  89 45 FC	     2	        mov      DWORD PTR @CatStr(_X,0), eax         ; _a0
 000025CF  8B 41 0C	     2	        mov      eax, DWORD PTR [ecx+3*SIZEOF DWORD]  ; RK[0]
 000025D2  8B 55 E0	     2	        mov      edx, DWORD PTR  @CatStr(_Y,3)        ; _b0
 000025D5  C1 EA 18	     2	        shr      edx, 24                        
 000025D8  0F B6 D2	     2	        movzx    edx, dl
 000025DB  0F B6 92	     2	        movzx    edx, BYTE PTR _Rsb[edx]               ; Fsb / RSb[(uint8)(Y0 >> 24)]
	   0000330C R
 000025E2  C1 E2 18	     2	        shl      edx, 24                        
 000025E5  33 C2	     2	        xor      eax, edx
 000025E7  8B 55 E4	     2	        mov      edx, DWORD PTR @CatStr(_Y,2)         ; _b1
 000025EA  C1 EA 10	     2	        shr      edx, 16                        
 000025ED  0F B6 D2	     2	        movzx    edx, dl
 000025F0  0F B6 92	     2	        movzx    edx, BYTE PTR _Rsb[edx]
	   0000330C R
 000025F7  C1 E2 10	     2	        shl      edx, 16                        
 000025FA  33 C2	     2	        xor      eax, edx
 000025FC  8B 55 E8	     2	        mov      edx, DWORD PTR @CatStr(_Y,1)         ; _b2
 000025FF  C1 EA 08	     2	        shr      edx, 8
 00002602  0F B6 D2	     2	        movzx    edx, dl
 00002605  0F B6 92	     2	        movzx    edx, BYTE PTR _Rsb[edx]
	   0000330C R
 0000260C  C1 E2 08	     2	        shl      edx, 8
 0000260F  33 C2	     2	        xor      eax, edx
 00002611  0F B6 55 EC	     2	        movzx    edx, BYTE PTR @CatStr(_Y,0)          ; _b3
 00002615  0F B6 92	     2	        movzx    edx, BYTE PTR _Rsb[edx]
	   0000330C R
 0000261C  33 C2	     2	        xor      eax, edx
 0000261E  89 45 F0	     2	        mov      DWORD PTR @CatStr(_X,3), eax         ; _a0
 00002621  8B 41 08	     2	        mov      eax, DWORD PTR [ecx+2*SIZEOF DWORD]  ; RK[0]
 00002624  8B 55 E4	     2	        mov      edx, DWORD PTR  @CatStr(_Y,2)        ; _b0
 00002627  C1 EA 18	     2	        shr      edx, 24                        
 0000262A  0F B6 D2	     2	        movzx    edx, dl
 0000262D  0F B6 92	     2	        movzx    edx, BYTE PTR _Rsb[edx]               ; Fsb / RSb[(uint8)(Y0 >> 24)]
	   0000330C R
 00002634  C1 E2 18	     2	        shl      edx, 24                        
 00002637  33 C2	     2	        xor      eax, edx
 00002639  8B 55 E8	     2	        mov      edx, DWORD PTR @CatStr(_Y,1)         ; _b1
 0000263C  C1 EA 10	     2	        shr      edx, 16                        
 0000263F  0F B6 D2	     2	        movzx    edx, dl
 00002642  0F B6 92	     2	        movzx    edx, BYTE PTR _Rsb[edx]
	   0000330C R
 00002649  C1 E2 10	     2	        shl      edx, 16                        
 0000264C  33 C2	     2	        xor      eax, edx
 0000264E  8B 55 EC	     2	        mov      edx, DWORD PTR @CatStr(_Y,0)         ; _b2
 00002651  C1 EA 08	     2	        shr      edx, 8
 00002654  0F B6 D2	     2	        movzx    edx, dl
 00002657  0F B6 92	     2	        movzx    edx, BYTE PTR _Rsb[edx]
	   0000330C R
 0000265E  C1 E2 08	     2	        shl      edx, 8
 00002661  33 C2	     2	        xor      eax, edx
 00002663  0F B6 55 E0	     2	        movzx    edx, BYTE PTR @CatStr(_Y,3)          ; _b3
 00002667  0F B6 92	     2	        movzx    edx, BYTE PTR _Rsb[edx]
	   0000330C R
 0000266E  33 C2	     2	        xor      eax, edx
 00002670  89 45 F4	     2	        mov      DWORD PTR @CatStr(_X,2), eax         ; _a0
 00002673  8B 41 04	     2	        mov      eax, DWORD PTR [ecx+1*SIZEOF DWORD]  ; RK[0]
 00002676  8B 55 E8	     2	        mov      edx, DWORD PTR  @CatStr(_Y,1)        ; _b0
 00002679  C1 EA 18	     2	        shr      edx, 24                        
 0000267C  0F B6 D2	     2	        movzx    edx, dl
 0000267F  0F B6 92	     2	        movzx    edx, BYTE PTR _Rsb[edx]               ; Fsb / RSb[(uint8)(Y0 >> 24)]
	   0000330C R
 00002686  C1 E2 18	     2	        shl      edx, 24                        
 00002689  33 C2	     2	        xor      eax, edx
 0000268B  8B 55 EC	     2	        mov      edx, DWORD PTR @CatStr(_Y,0)         ; _b1
 0000268E  C1 EA 10	     2	        shr      edx, 16                        
 00002691  0F B6 D2	     2	        movzx    edx, dl
 00002694  0F B6 92	     2	        movzx    edx, BYTE PTR _Rsb[edx]
	   0000330C R
 0000269B  C1 E2 10	     2	        shl      edx, 16                        
 0000269E  33 C2	     2	        xor      eax, edx
 000026A0  8B 55 E0	     2	        mov      edx, DWORD PTR @CatStr(_Y,3)         ; _b2
 000026A3  C1 EA 08	     2	        shr      edx, 8
 000026A6  0F B6 D2	     2	        movzx    edx, dl
 000026A9  0F B6 92	     2	        movzx    edx, BYTE PTR _Rsb[edx]
	   0000330C R
 000026B0  C1 E2 08	     2	        shl      edx, 8
 000026B3  33 C2	     2	        xor      eax, edx
 000026B5  0F B6 55 E4	     2	        movzx    edx, BYTE PTR @CatStr(_Y,2)          ; _b3
Microsoft (R) Macro Assembler Version 14.28.29910.0	    02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 55 - 1


 000026B9  0F B6 92	     2	        movzx    edx, BYTE PTR _Rsb[edx]
	   0000330C R
 000026C0  33 C2	     2	        xor      eax, edx
 000026C2  89 45 F8	     2	        mov      DWORD PTR @CatStr(_X,1), eax         ; _a0
 000026C5		     1	??001B:
				        
				        ; PUT_UINT32_BE( X0, output,  0 );               ; Put encrypted data
				        _PUT_UINT32 _X0, _output, 0
 000026C5  8B 4D 10	     1	        mov      ecx, DWORD PTR _output
 000026C8  8B 45 FC	     1	        mov      eax, DWORD PTR _X0                      ; Bits[31:0]
 000026CB  0F C8	     1	        bswap    eax                                    ; Reverse the byte order
 000026CD  89 01	     1	        mov      DWORD PTR [ecx+0*SIZEOF DWORD], eax   ; Bits[31:0]
				        ; PUT_UINT32_BE( X1, output,  4 );
				        _PUT_UINT32 _X1, _output, 1
 000026CF  8B 4D 10	     1	        mov      ecx, DWORD PTR _output
 000026D2  8B 45 F8	     1	        mov      eax, DWORD PTR _X1                      ; Bits[31:0]
 000026D5  0F C8	     1	        bswap    eax                                    ; Reverse the byte order
 000026D7  89 41 04	     1	        mov      DWORD PTR [ecx+1*SIZEOF DWORD], eax   ; Bits[31:0]
				        ; PUT_UINT32_BE( X2, output,  8 );
				        _PUT_UINT32 _X2, _output, 2
 000026DA  8B 4D 10	     1	        mov      ecx, DWORD PTR _output
 000026DD  8B 45 F4	     1	        mov      eax, DWORD PTR _X2                      ; Bits[31:0]
 000026E0  0F C8	     1	        bswap    eax                                    ; Reverse the byte order
 000026E2  89 41 08	     1	        mov      DWORD PTR [ecx+2*SIZEOF DWORD], eax   ; Bits[31:0]
				        ; PUT_UINT32_BE( X3, output, 12 );
				        _PUT_UINT32 _X3, _output, 3
 000026E5  8B 4D 10	     1	        mov      ecx, DWORD PTR _output
 000026E8  8B 45 F0	     1	        mov      eax, DWORD PTR _X3                      ; Bits[31:0]
 000026EB  0F C8	     1	        bswap    eax                                    ; Reverse the byte order
 000026ED  89 41 0C	     1	        mov      DWORD PTR [ecx+3*SIZEOF DWORD], eax   ; Bits[31:0]

				         ret
 000026F0  5F		   *	    pop    edi
 000026F1  5E		   *	    pop    esi
 000026F2  5B		   *	    pop    ebx
 000026F3  C9		   *	    leave  
 000026F4  C3		   *	    ret    00000h
 000026F5			_aesAlgorithm ENDP ; _aesAlgorithm


				;------------------------------------------------------------------------------
				; 
				;                       aesAlgorithm
				;
				;      Function compile flags: /Odtp
				;                                                                                          
				;      void aesAlgorithm(char *inblock, char *outblock, int _mode)
				;
				;      aesAlgorithm PROTO C, :DWORD, :DWORD, :DWORD
				;
				;      Language type: PROC C (Public interface to aesfastmain.cpp)
				;      aesfastmain.cpp: extern "C" void aesAlgorithm (char*, char*, int);
				;
				;      Stub to invoke aesEncrypt & aesDecrypt procedures
				;
 000026F5			aesAlgorithm PROC C PUBLIC USES ebx esi edi, _inblock:DWORD, _outblock:DWORD, _mode:DWORD
				;
				; NOTE: The '_mode:DWORD parameter is not used in this AESfast.ASM module,
				;       but we force compatibility with the AES.CPP module in order
				;       to have (nearly) equal haCryptAESfast.CPP / haCryptAES.CPP modules.
				;
				; The invocation paremeters for _aesAlgorithm must be re-arranged:
				;  aesAlgorithm(char *inblock, char *outblock);
				;  -->
				;  aes_encrypt(&ctx, (unsigned char *)inblock, (unsigned char *)outblock);
				;  aes_decrypt(&ctx, (unsigned char *)inblock, (unsigned char *)outblock);
				;  <--
				;
				;  Parameter translation is applied as follows:
				;  aesAlgorithm() -->  _aesAlgorithm() = aesEncrypt & aesDcrypt
				;  -------------------------------------------------------------
				;  _inblock       <--  OFFSET ctxAesContext  (ctx    = [-12+08])
				;  _outblock      <--  _inblock              (inbuf  = [-12+12])
				;                 <--  _outblock             (outbuf = [-12+16])
				;
 000026F5  55		   *	    push   ebp
 000026F6  8B EC	   *	    mov    ebp, esp
 000026F8  53		   *	    push   ebx
 000026F9  56		   *	    push   esi
 000026FA  57		   *	    push   edi
Microsoft (R) Macro Assembler Version 14.28.29910.0 02/24/25 18:17:20
C:\Temp600\__\aesfast.asm				     Page 56 - 1


				        INVOKE _aesAlgorithm, OFFSET ctxAesContext, _inblock, _outblock
 000026FB  FF 75 0C	   *	    push   dword  ptr ss:[ebp]+00000000Ch
 000026FE  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 00002701  68 00000008 R   *	    push   dword  ptr OFFSET FLAT: ctxAesContext
 00002706  E8 FFFFE0E0	   *	    call   _aesAlgorithm
 0000270B  83 C4 0C	   *	    add    esp, 00000000Ch
				        ret
 0000270E  5F		   *	    pop    edi
 0000270F  5E		   *	    pop    esi
 00002710  5B		   *	    pop    ebx
 00002711  C9		   *	    leave  
 00002712  C3		   *	    ret    00000h
 00002713			aesAlgorithm ENDP ; aesAlgorithm


				;------------------------------------------------------------------------------
				;
				;                               aesKeyInit
				;
				;       void aesKeyInit(char *key, int keylen, int mode)
				;
				;       kinit PROTO C, key:DWORD, edf:DWORD
				;
				;      Language type: PROC C (Public interface to aesfastmain.cpp)
				;      aesfastmain.cpp: extern "C" void aesKeyInit(char*, int, int);
				;
				;      Stub to initialize key schedule array for aes
				;
 00002713			aesKeyInit PROC C PUBLIC USES ebx esi edi, _key:DWORD, _keylen:DWORD, _mode:DWORD
 00002713  55		   *	    push   ebp
 00002714  8B EC	   *	    mov    ebp, esp
 00002716  53		   *	    push   ebx
 00002717  56		   *	    push   esi
 00002718  57		   *	    push   edi
 00002719  C7 05 00000004 R	        mov      DWORD PTR aesMode, _ctxStruct.erk ; .erk Encrypt Struct
	   00000000
 00002723  8B 45 10		        mov      eax, DWORD PTR _mode
 00002726  83 F8 00		        cmp      eax, ENCRYPT
 00002729  74 0A		        je       @F

 0000272B  C7 05 00000004 R	        mov      DWORD PTR aesMode, _ctxStruct.drk ; .drk Decipher Struct
	   00000100
 00002735			@@:
				        INVOKE aesSetKey, OFFSET ctxAesContext, _key, _keylen
 00002735  FF 75 0C	   *	    push   dword  ptr ss:[ebp]+00000000Ch
 00002738  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 0000273B  68 00000008 R   *	    push   dword  ptr OFFSET FLAT: ctxAesContext
 00002740  E8 FFFFDC51	   *	    call   aesSetKey
 00002745  83 C4 0C	   *	    add    esp, 00000000Ch
				        ret
 00002748  5F		   *	    pop    edi
 00002749  5E		   *	    pop    esi
 0000274A  5B		   *	    pop    ebx
 0000274B  C9		   *	    leave  
 0000274C  C3		   *	    ret    00000h
 0000274D			aesKeyInit ENDP ; aesKeyInit
				 
				;------------------------------------------------------------------------------

 0000274D			_TEXT   ENDS
				        END
